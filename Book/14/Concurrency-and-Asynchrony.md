# فصل چهاردهم: هم‌زمانی و ناهم‌زمانی

بیشتر برنامه‌ها نیاز دارند با بیش از یک رویداد که به‌طور هم‌زمان رخ می‌دهد سروکار داشته باشند (هم‌زمانی یا **Concurrency**).
در این فصل، ما با پیش‌نیازهای ضروری شروع می‌کنیم، یعنی مبانی **Threading** (ایجاد و مدیریت رشته‌ها) و **Tasks** (وظایف)، و سپس اصول **Asynchrony** (ناهم‌زمانی) و توابع ناهم‌زمان در #C را با جزئیات توضیح می‌دهیم.

در **فصل ۲۱** دوباره به موضوع **Multithreading** (چند‌رشته‌ای) با جزئیات بیشتر برمی‌گردیم و در **فصل ۲۲** موضوع مرتبط یعنی **Parallel Programming** (برنامه‌نویسی موازی) را پوشش می‌دهیم.

---

## 🔹 مقدمه

در ادامه رایج‌ترین سناریوهای هم‌زمانی آورده شده است:

### 🖥️ نوشتن یک رابط کاربری پاسخ‌گو

در برنامه‌های **WPF**، موبایل و **Windows Forms** باید کارهای زمان‌بر را به‌صورت هم‌زمان با کدی که رابط کاربری شما را اجرا می‌کند انجام دهید تا رابط کاربری همچنان پاسخ‌گو باقی بماند.

### 🌐 پردازش هم‌زمان درخواست‌ها

روی یک سرور، درخواست‌های کلاینت می‌توانند به‌طور هم‌زمان برسند و بنابراین باید به‌صورت موازی پردازش شوند تا **Scalability** (مقیاس‌پذیری) حفظ شود. اگر از **ASP.NET Core** یا **Web API** استفاده کنید، زمان‌اجرا (Runtime) این کار را به‌طور خودکار برای شما انجام می‌دهد.
بااین‌حال، همچنان باید نسبت به **Shared State** (وضعیت مشترک) آگاه باشید (برای نمونه، اثر استفاده از **Static Variables** برای کش‌کردن).

### ⚡ برنامه‌نویسی موازی

کدی که محاسبات سنگینی انجام می‌دهد می‌تواند روی رایانه‌های چند‌هسته‌ای یا چند‌پردازنده‌ای سریع‌تر اجرا شود، اگر حجم کار میان هسته‌ها تقسیم شود. (فصل ۲۲ به‌طور کامل به این موضوع اختصاص دارد.)

### 🔮 اجرای حدسی (Speculative Execution)

روی ماشین‌های چند‌هسته‌ای، گاهی می‌توان با پیش‌بینی کاری که ممکن است نیاز به انجام آن باشد و انجام دادن آن از قبل، عملکرد را بهبود داد.
برنامه **LINQPad** از این تکنیک برای سرعت‌بخشیدن به ایجاد کوئری‌های جدید استفاده می‌کند.
نوع دیگری از این روش این است که چند الگوریتم مختلف را به‌طور موازی اجرا کنید که همگی یک وظیفه مشابه را حل می‌کنند. هرکدام زودتر تمام شود «برنده» خواهد بود. این روش زمانی مؤثر است که از قبل ندانید کدام الگوریتم سریع‌تر عمل خواهد کرد.

---

## 🧵 مکانیزم عمومی هم‌زمانی: Multithreading

مکانیزم عمومی‌ای که به یک برنامه اجازه می‌دهد به‌طور هم‌زمان کد را اجرا کند، **Multithreading** نام دارد.
Multithreading هم توسط **CLR** و هم توسط **سیستم‌عامل** پشتیبانی می‌شود و یک مفهوم بنیادین در هم‌زمانی است.
بنابراین درک مبانی **Threading**، و به‌ویژه تأثیر رشته‌ها بر **Shared State** (وضعیت مشترک)، ضروری است.

---

## 🧩 Threading

یک **Thread** یا «رشته»، یک مسیر اجرای مستقل است که می‌تواند جدا از سایر مسیرها پیش برود.

هر رشته درون یک **Process** (فرایند) سیستم‌عامل اجرا می‌شود که محیطی ایزوله را برای اجرای یک برنامه فراهم می‌کند.

* در یک برنامه **تک‌رشته‌ای** (Single-Threaded)، تنها یک رشته در محیط ایزوله پردازش اجرا می‌شود و بنابراین آن رشته دسترسی انحصاری به آن دارد.
* در یک برنامه **چند‌رشته‌ای** (Multi-Threaded)، چند رشته در یک فرایند واحد اجرا می‌شوند و یک محیط اجرایی مشترک (به‌ویژه حافظه) را با هم به اشتراک می‌گذارند.

این موضوع دلیل اصلی مفید بودن Multithreading است:
برای نمونه، یک رشته می‌تواند در پس‌زمینه داده‌ها را واکشی کند، درحالی‌که رشته دیگر همان داده‌ها را به‌محض رسیدن نمایش دهد. این داده‌ها به‌عنوان **Shared State** شناخته می‌شوند.

---

## 🛠️ ایجاد یک Thread

یک برنامه کلاینت (**Console**، **WPF**، **UWP** یا **Windows Forms**) در یک رشته منفرد که به‌طور خودکار توسط سیستم‌عامل ساخته می‌شود (رشته‌ی اصلی یا **Main Thread**) شروع به کار می‌کند.
این برنامه تا زمانی که شما کاری خلاف آن انجام ندهید (یعنی رشته‌های بیشتری بسازید، چه به‌طور مستقیم و چه غیرمستقیم) به‌صورت تک‌رشته‌ای باقی می‌ماند.¹

برای ایجاد و شروع یک رشته جدید، باید یک شیء از نوع **Thread** بسازید و متد **Start** آن را فراخوانی کنید.
ساده‌ترین سازنده (Constructor) برای Thread، یک **ThreadStart Delegate** می‌گیرد: متدی بدون پارامتر که نشان می‌دهد اجرای رشته از کجا آغاز شود.

### 📌 مثال:

```csharp
// توجه: همه نمونه‌های این فصل فرض می‌کنند که Namespaceهای زیر Import شده‌اند:
using System;
using System.Threading;

Thread t = new Thread (WriteY);     // ایجاد و راه‌اندازی یک رشته جدید
t.Start();                          // اجرای متد WriteY روی رشته جدید

// هم‌زمان، روی رشته اصلی هم کاری انجام می‌دهیم.
for (int i = 0; i < 1000; i++) Console.Write ("x");

void WriteY()
{
    for (int i = 0; i < 1000; i++) Console.Write ("y");
}
```

---

### 📤 خروجی نمونه:

```
xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
...
```

---

رشته اصلی یک رشته جدید به نام `t` می‌سازد و روی آن متدی را اجرا می‌کند که کاراکتر `y` را به‌طور تکراری چاپ می‌کند.
به‌طور هم‌زمان، رشته اصلی نیز کاراکتر `x` را به‌طور تکراری چاپ می‌کند، همان‌طور که در شکل **۱۴-۱** نشان داده شده است.

* روی یک رایانه تک‌هسته‌ای، سیستم‌عامل باید «بُرش‌هایی» از زمان (معمولاً حدود **۲۰ میلی‌ثانیه** در ویندوز) را به هر رشته اختصاص دهد تا هم‌زمانی شبیه‌سازی شود. نتیجه این کار، بلاک‌های تکراری از `x` و `y` است.
* روی یک ماشین چند‌هسته‌ای یا چند‌پردازنده‌ای، دو رشته می‌توانند واقعاً به‌طور موازی اجرا شوند (با این شرط که دیگر پردازه‌های فعال روی رایانه هم در رقابت باشند).
  بااین‌حال در این مثال همچنان بلاک‌های تکراری از `x` و `y` مشاهده می‌کنید، زیرا جزئیات ظریفی در مکانیزمی وجود دارد که **Console** درخواست‌های هم‌زمان را مدیریت می‌کند.

<div align="center">
    
![Conventions-UsedThis-Book](../../assets/image/14/Table-14-1.jpeg) 
</div>

## 🔄 پیش‌امتیازدهی (Preemption)

وقتی اجرای یک **Thread** با اجرای کدی روی یک **Thread** دیگر در هم آمیخته می‌شود، گفته می‌شود که آن Thread **Preempted** (پیش‌امتیاز داده شده) است. این اصطلاح اغلب زمانی ظاهر می‌شود که بخواهیم توضیح دهیم چرا چیزی به‌درستی کار نکرده است!

---

## 🟢 وضعیت زنده بودن (IsAlive)

پس از شروع شدن، ویژگی (**Property**) `IsAlive` در یک Thread مقدار **true** را برمی‌گرداند تا زمانی که آن Thread پایان یابد.
یک Thread زمانی پایان می‌یابد که **Delegate**ای که به سازنده‌ی (Constructor) آن داده شده، اجرای خود را تمام کند. پس از پایان یافتن، یک Thread را نمی‌توان دوباره راه‌اندازی کرد.

---

## 📝 نام‌گذاری Threadها

هر Thread یک ویژگی به نام **Name** دارد که می‌توانید آن را برای اهداف **Debugging** تنظیم کنید.
این ویژگی در **Visual Studio** بسیار مفید است، زیرا نام Thread در **Threads Window** و نوار ابزار **Debug Location** نمایش داده می‌شود.
شما تنها یک‌بار می‌توانید نام یک Thread را تنظیم کنید؛ هر تلاش دیگری برای تغییر نام، یک **Exception** ایجاد خواهد کرد.

---

## 🔍 دسترسی به Thread فعلی

ویژگی استاتیک `Thread.CurrentThread` رشته‌ای را که در حال حاضر در حال اجراست برمی‌گرداند:

```csharp
Console.WriteLine (Thread.CurrentThread.Name);
```

---

## ⏳ Join و Sleep

### 📌 Join

می‌توانید با فراخوانی متد **Join** منتظر بمانید تا یک Thread دیگر پایان یابد:

```csharp
Thread t = new Thread (Go);
t.Start();
t.Join();
Console.WriteLine ("Thread t has ended!");

void Go() 
{ 
    for (int i = 0; i < 1000; i++) Console.Write ("y"); 
}
```

این کد ابتدا ۱۰۰۰ بار `y` چاپ می‌کند و بلافاصله پس از آن متن `"Thread t has ended!"` نمایش داده می‌شود.

همچنین می‌توانید هنگام فراخوانی **Join** یک **Timeout** مشخص کنید (برحسب میلی‌ثانیه یا یک **TimeSpan**). در این صورت متد مقدار **true** برمی‌گرداند اگر Thread پایان یافته باشد، یا **false** اگر زمان تمام شده باشد.

---

### 📌 Sleep

متد **Thread.Sleep** اجرای Thread فعلی را برای مدتی مشخص متوقف می‌کند:

```csharp
Thread.Sleep (TimeSpan.FromHours (1));  // توقف برای ۱ ساعت
Thread.Sleep (500);                     // توقف برای ۵۰۰ میلی‌ثانیه
```

فراخوانی `Thread.Sleep(0)` بلافاصله **بُرش زمانی** (Time Slice) فعلی را آزاد کرده و داوطلبانه CPU را در اختیار سایر Threadها قرار می‌دهد.
متد `Thread.Yield()` نیز همین کار را انجام می‌دهد، با این تفاوت که CPU را تنها به Threadهایی واگذار می‌کند که روی همان پردازنده در حال اجرا هستند.

* استفاده از `Sleep(0)` یا `Yield` گاهی در کدهای **Production** برای بهینه‌سازی‌های پیشرفته‌ی عملکرد مفید است.
* این‌ها همچنین ابزارهای عالی **Diagnostic** (عیب‌یابی) هستند: اگر اضافه کردن `Thread.Yield()` در هرجای کد شما باعث خراب شدن برنامه شود، تقریباً مطمئن باشید که یک **Bug** در کدتان وجود دارد.

---

## 🚫 Block شدن یک Thread

وقتی اجرای یک Thread به دلایلی متوقف شود، گفته می‌شود که آن Thread **Blocked** است؛ مثلاً هنگام اجرای **Sleep** یا منتظر ماندن برای پایان یافتن یک Thread دیگر با **Join**.

* یک Thread **Blocked** بلافاصله بُرش زمانی پردازنده‌ی خود را آزاد می‌کند.
* از آن لحظه به بعد، هیچ زمانی از CPU مصرف نمی‌کند تا زمانی که شرط Block شدن برطرف شود.

برای بررسی اینکه آیا یک Thread در حالت Block است می‌توانید از ویژگی **ThreadState** استفاده کنید:

```csharp
bool blocked = (someThread.ThreadState & ThreadState.WaitSleepJoin) != 0;
```

---

## ⚙️ ThreadState

ویژگی **ThreadState** یک **Flags Enum** است که سه «لایه» داده را به‌صورت **Bitwise** ترکیب می‌کند.
بااین‌حال بیشتر مقادیر آن زائد، بلااستفاده یا منسوخ شده‌اند.

روش توسعه‌یافته‌ی زیر یک مقدار ThreadState را به یکی از چهار مقدار مفید ساده‌سازی می‌کند:

* **Unstarted**
* **Running**
* **WaitSleepJoin**
* **Stopped**

```csharp
public static ThreadState Simplify (this ThreadState ts)
{
    return ts & (ThreadState.Unstarted |
                 ThreadState.WaitSleepJoin |
                 ThreadState.Stopped);
}
```

🔎 ویژگی ThreadState برای مقاصد **Diagnostic** مفید است، اما برای **Synchronization** مناسب نیست، زیرا وضعیت یک Thread می‌تواند بین بررسی مقدار ThreadState و عمل‌کردن بر اساس آن تغییر کند.

هنگامی‌که یک Thread **Block** یا **Unblock** می‌شود، سیستم‌عامل یک **Context Switch** انجام می‌دهد. این عمل هزینه‌ی اندکی دارد (معمولاً یک یا دو میکروثانیه).

---

## ⚖️ I/O-bound در مقابل Compute-bound

* عملیاتی که بیشتر زمان خود را در انتظار رخ‌دادن چیزی می‌گذراند، **I/O-bound** نامیده می‌شود.
  نمونه: **دانلود یک صفحه وب** یا فراخوانی `Console.ReadLine`.
  (عملیات I/O-bound معمولاً شامل ورودی یا خروجی هستند، اما این یک الزام قطعی نیست: `Thread.Sleep` هم I/O-bound محسوب می‌شود.)

* در مقابل، عملیاتی که بیشتر زمان خود را صرف انجام کارهای سنگین CPU می‌کند، **Compute-bound** نام دارد.

---

## 🔄 Blocking در مقابل Spinning

یک عملیات I/O-bound می‌تواند به دو صورت عمل کند:

1. **انتظار همگام (Synchronous)** روی Thread فعلی تا پایان عملیات (مثال: `Console.ReadLine`، `Thread.Sleep` یا `Thread.Join`).
2. **عمل ناهمگام (Asynchronous)** که با پایان عملیات در آینده، یک **Callback** اجرا می‌کند (بیشتر در ادامه این فصل توضیح داده می‌شود).

---

### 🔁 Blocking با حلقه Sleep

عملیات‌های I/O-bound که به‌صورت همگام منتظر می‌مانند بیشتر زمان خود را در حالت Block سپری می‌کنند.
گاهی این انتظار به شکل یک حلقه‌ی Sleep پیاده‌سازی می‌شود:

```csharp
while (DateTime.Now < nextStartTime)
    Thread.Sleep (100);
```

---

### 🔁 Spinning (چرخش مداوم)

گزینه‌ی دیگر این است که یک Thread به‌طور مداوم بچرخد:

```csharp
while (DateTime.Now < nextStartTime);
```

این کار به‌شدت وقت CPU را تلف می‌کند. از دید **CLR** و سیستم‌عامل، Thread در حال انجام یک محاسبه مهم است، بنابراین منابع به آن اختصاص داده می‌شود. در عمل، ما یک عملیات I/O-bound را به یک عملیات **Compute-bound** تبدیل کرده‌ایم.

---

## ✨ نکات ظریف درباره Spinning در برابر Blocking

۱. **Spinning کوتاه‌مدت** گاهی می‌تواند مؤثر باشد، زمانی که انتظار دارید شرط به‌زودی (مثلاً در چند میکروثانیه) برقرار شود. این کار از سربار و تأخیر **Context Switch** جلوگیری می‌کند.
📌 برای این منظور، .NET متدها و کلاس‌های خاصی مثل **SpinLock** و **SpinWait** را ارائه می‌دهد.

۲. **Blocking هم بی‌هزینه نیست**. هر Thread حدود **۱ مگابایت حافظه** را برای تمام مدت عمرش اشغال می‌کند و برای **CLR** و سیستم‌عامل بار مدیریتی مداوم ایجاد می‌کند.
به همین دلیل، Blocking در برنامه‌های بسیار I/O-bound که باید صدها یا هزاران عملیات هم‌زمان را مدیریت کنند می‌تواند مشکل‌ساز شود.

🔑 در چنین شرایطی، برنامه‌ها باید از رویکرد **Callback-based** استفاده کنند، یعنی هنگام انتظار، Thread خود را به‌طور کامل آزاد کنند.
این دقیقاً (بخشی از) هدف الگوهای **Asynchronous** است که در ادامه بررسی خواهیم کرد.
