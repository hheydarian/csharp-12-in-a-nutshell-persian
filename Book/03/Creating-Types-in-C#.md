# فصل سوم : ایجاد انواع نوع داده در سی شارپ

![Conventions-UsedThis-Book](/assets/image/03/ImageStartChapter3.png)


در این فصل ما به سمت بررسی کردن انواع  داده و  اعضای نوع میپردازیم 

## کلاس ها

یک `class` پرکاربردترین گونه از نوع ارجاعی است. ساده‌ترین ساختار ممکن برای اعلان یک کلاس این‌گونه است:
```Cs
class YourClassName{

}
```
یک کلاس پیچیده‌تر می‌تواند به صورت  اختیاری دارای بخش های زیر باشد : 
پیش از واژه کلیدی `class`:
صفت ها و اصلاح کننده های کلاس. اصلاح کننده های که تو در کلاس های  تو در تو نمیبینی ، عبارتند از : 
`partial` , `public` , `internal` , `abstract` , `sealed` , `static` و `unsage` 
پس از `YourClassName` : 
پارامتر های نوع عمومی (Generic Type) و محدودیت‌ها، یک کلاس پایه و رابط‌ها

### درون آکولاد ها {} : 
اعضای کلاس (این اعضا : متدها ، ویژگی ها، ایندکسرها، رویدادها ،فیلدها، سازنده‌ها ، عمگرهای سربار گذاری شده  و انواع تودرتو و یک فاینالیزر هستند).

این بخش تمام این سازه‌ها به جز صفت ها، توابع عملگر و واژه کلیدی `unsafe` را پوشش می دهد، 
که آن‌ها در فصل چهارم پوشش داده شده اند. بخش های زیر به شرح هر یک از اعضای کلاس می پردازد.


## فیلد ها (Fields) : 

یک فیلد یک متغیر است که بخشی از اعضای یک کلاس و استراکت به حساب می آید برای نمونه : 
```Cs
class Octopus{
    string name;
    public int age = 10;
}
```

فیلد ها اجازه استفاده از اصلاح‌کننده(modifers) رو دارند :
**اصلاح‌کننده‌** **استاتیک**(Static modifier) : `static` 
**اصلاح‌کننده** **دسترسی**(Access modifers ) : `public` `internal` `private` `protected`
**اصلاح‌کننده** **وراثت**(Inheritance modifier) : `new`
**اصلاح‌کننده** **ناایمن**(Unsafe modifier) : `unsafe`
**اصلاح‌کننده** **فقط-خواندنی**(Read-only modifier) : `readonly`
**اصلاح‌کننده نخ‌کشی**(Threading modifier) :  `volatile`

## پیمان‌نامه نام‌گذاری (Naming Conventions) : 
دو پیمان‌‌نامه  نام‌گذاری رایج برای فید های خصوصی وجود دارد: 
- `شتروار (camel-cased)` : firstName 
- `شتروار با خط زیرین (camel-cased with an underscore)` : _firstName 
پیمان نامه دوم به تو اجازه میده تا به سرعت فیلد‌های خصوصی را از پارامتر‌ها و متغیرهای محلی شناسایی کنی.
در بسیاری از زبان ها از پیمان‌نامه دوم استفاده میشود

## اصلاح‌کننده readonly
این اصلاح‌کننده ، فیلد را پس از ساخته شدن غیرقابل ویراش می کند.
یک فیلد فقط-خواندنی را می‌توان تنها در اعلان یا درون سازنده نوع دربرگیرنده آن مقداردهی کرد.

## مقداردهی اولیه فیلد : 
مقداردهی اولیه به فیلدها اختیاری است.
یک فیلد مقداردهی نشده ، یک مقدار پیش‌فرض دارد (برای نمونه : false , null , 0 , \0)
مقداردهی اولیه فیلد پیش از سازنده ها اجرا میشود : 
```Cs
public int Age = 10;
```
یک مقداردهی اولیه فیلد میتواند دربرگیرنده عبارت ها و فراخوانی متدها باشد : 
```Cs
static readonly string TempFolder = System.IO.Path.GetTempPath();
```
در اینجا ما از مقدار بازگشتی `GetTempPath` متغیر `TempFolder` را مقداردهی کردیم


## اعلان هم‌زمان چند فیلد (Declaring multiple fields together) : 

برای آسان سازی ، ما میتوانیم چندین فیلد را از یک نوع را با یک فهرست جداشده با کاما اعلان کنیم.
این روش مناسب برای اشتراک‌گذاری صفت ها و اصلاح‌کننده های فیلد است : 
```Cs
static readonly int legs = 8,
                    eyse = 2;
```

## ثابت ها (Constants) : 
یک ثابت به صورت ایستا و در زمان کامپایل ارزیابی میشود و کامپایلر در هر جایی که از آن استفاده شود ، مقدارش را جایگزین میکند (مانند ماکرو در زبان C++ ).
یک ثابت می‌تواند از نوع `string` , `char` , `bool`و هر یک از انواع عددی داخلی یا یک نوع `enum` باشد.


یک ثابت با واژه کلیدی `const` اعلان می‌شود و باید با یک مقدار مقداردهی اولیه شود.
برای نمونه : 
```Cs
public class Test{
    public const string Message = "Hello World!";
}
```
یک ثابت میتواند نقشی همانند یک فیلد `static readonly` داشته باشد ، اما بسیار محدودتر است،
هم از نظر نوع‌هایی که میتوانی به کار ببری و هم از نظر معنای مقداردهی اولیه فیلد.

یک ثابت همچنین با فیلد `static readonly` فرق دارد ، زیرا ارزیابی ثابت در زمان کامپایل رخ میدهد ، از این رو :
```Cs
public static double Circumference (double radius)
{
 return 2 * System.Math.PI * radius;
}
```
به این صورت کامپایل میشود : 
```Cs
public static double Circumference (double radius)
{
 return 6.2831853071795862 * radius;
}

```
برای عدد `PI` منطقی است که ثابت باشد ، چرا که مقدار آن در زمان کامپایل از پیش تعیین شده است.
در مقابل ، مقدار یک فیلد `static readonly` می تواند هر بار که برنامه اجرا می شود، متفاوت باشد:
```Cs
static readonly DateTime StartupTime = DateTime.Now;
```

یک فیلد `static readonly` هنگامی که یک مقدار را به اسمبلی های دیگر نمایش می‌دهی و ممکن است آن مقدار در نسخه بعدی تغییر کند ، مزیت دارد. برای نمونه ، فرض کن اسمبلی `X` یک ثابت را این گونه نمایش میدهد:
```Cs
public const decimal ProgramVersion = 2.3;
```
اگر اسمبلی `Y` به `X` ارجاع دهد و از این ثابت استفاده کند، مقدار `2.3` در زمان کامپایل در اسمبلی `Y` جاسازی می‌شود. این به این معنی است که اگر بعدها `X` با ثابت `2.4` دوباره کامپایل شود، `Y` همچنان از مقدار قدیمی `2.3` استفاده خواهد کرد، تا زمانی که `Y` دوباره کامپایل شود. یک فیلد `static readonly` از این مشکل جلوگیری می‌کند.
از نگاهی دیگر، هر مقداری که ممکن است در آینده تغییر کند، به تعریف «ثابت» نیست؛ بنابراین نباید به این شکل نمایش داده شود.

ثابت ها می توانند در درون یک متد نیز اعلان شوند : 
```Cs
void TestPI(){
    const double twoPI = 2 * System.Math.PI;
    //...
}
```
ثابت های غیر محلی اجازه استفاده از اصلاح کننده های زیر را دارند : 
**اصلاح‌کننده های دسترسی** : 
`private` `public` `internal` `protected`
**اصلاح‌کننده وراثت**:
`new`

## متد ها (Methods)
متد ها یکی از مفاهیم مهم در تمام زبان های برنامه نویسی است ،
یک متد ، یک کار را در یک سری از دستور ها انجام میدهد.
یک متد میتواند با شناساندن پارامتر‌ها ، داده‌های ورودی را از فراخواننده بگیرد و با شناساندن یک گونه‌ی بازگشتی، داده‌ها را به فراخواننده بازگرداند،
اگر بخواهیم کمی ساده تر توضیح دهیم ، متد ها مانند یک جعبه ابزار هستن به آنها مقدار اولیه را میدهیم و روی آن مقدار کاری را انجام میدهد و چیزی را پس میدهد.
یک متد میتواند یک گونه‌ی بازگشتی `void` را شناساند که نشان می‌دهد هیچ ارزشی(مقداری) را به فراخواننده‌ی خویش باز نمی‌گرداند.
یک متد همچنین میتواند داده‌ها را از راه پارامتر های `ref` و `out` به فراخواننده بازگردانند
(مانند پوینتر ها در زبان `C`)

امضای یک متد باید در درون یک گونه (type) بی همتا باشد. امضای یک متد ، از نام آن و گونه های پارامترها به ترتیب (اما نه نام پارامترها و نه گونه‌ی بازگشتی) تشکیل شده است.

- `پی نوشت : ` پالایشگاه : اصلاح‌کننده
واژه `اصلاح‌کننده` یک واژه عربی است و واژه `پالایشگاه یا پالایشگر` معادل پارسی آن است هر دو درست هستند.


متدها اجازه‌ی به کارگیری پالایشگرهای (modifiers) زیر را میدهد : 
- اصلاح‌کننده ایستا (Static modifier) : `static`
- اصلاح‌کننده های دسترسی (Access modifiers) : 
```Cs
public , internal , private , protected
```
- اصلاح‌کننده ارث‌ بری (Inheritance modifiers) : 
```Cs
new , virtual , abstract , override , sealed
```
- اصلاح‌کننده متد پاره‌ای(Partial method modifier) : `partial`

- اصلاح‌کننده کد ناهمزمان (Asynchronous code modifier) : 
`async`
نمونه : 
```Cs
static async Task Main(string[] args)
{
    Console.WriteLine("Starting...");
    await Task.Delay(3000);
    Console.WriteLine("Finished.");
}
```

**Task در C# نمایانگر یک عملیات ناهمزمان (asynchronous) است که می‌تواند در آینده به پایان برسد. این امکان را می‌دهد که برنامه به انجام کارهای دیگر ادامه دهد در حالی که منتظر نتیجه یک عملیات طولانی‌مدت است. در فصل های آینده در این باره بیشتر یاد خواهید گرفت**


### متد‌های بیان-پیکر  (Expression-bodied methods)
یک متد که از یک تک‌‌‌ بیان (single expression) ساخته شده است ، مانند : 
```Cs
int foo (int x) {
    return x * 2;
}
```
میتوانید به گونه‌ای کوتاه تر به شکل یک متد بیان-پیکر نوشته شود. در این شیوه ، یک پیکان فربه (`=>`) جای آکولاد‌ها و کلیدواژه‌ی `return` استفاده میگردد : 
```Cs
int foo (int x) => Console.WriteLine(x);
```
**همیشه به یاد داشته باشید کد بلند نشان بهتر بودن نیست همیشه کد را بهینه تر و کوتاه تر بکنید و قابل فهم تر**


### متد های بومی (Local methods)
شما میتوانید یک متد را در درون یک متد دیگر شناسایی کنید : 
```Cs
void WriteCubes(){
    Console.WriteLine(Cube(3));
    Console.WriteLine(Cube(4));
    Console.WriteLine(Cube(5));
    int Cube (int value) => value * value * value;
}
```

متد های بومی (در این نمونه `Cube`) تنها برای متد دربرگیرنده (در این نمونه `WriteCubes`) دیدنی است(دیدنی است به این معنا که دردسترس است). این کار ، گونه‌ی دربرگیرنده را ساده تر میکند و به همه‌ی کسانی که به کد نگاه میکنند، بی درنگ نشان می‌دهد که `Cube` در هیچ جای دیگری به کار نمی‌رود. یک فایده‌ی دیگر متد های بومی این است که می توانید  به متغیرهای بومی و پارامترهای متد دربرگیرنده دسترسی داشته باشید.
این کار، پیامدهای زیادی دارد که در بخش های آینده به ریزنگاری آن ها میپردازیم.


متدهای بومی میتوانند در درون گونه‌های کنشی دیگر نیز پدیدار شوند، مانند دسترسی سازهای ویژوگی(property accessors)، سازنده‌ها و مانند آن‌ها. شما حتی میتوانید متدهای بومی را در درون متدهای  بومی را در درون متدهای بومی دیگر و در درون بیان‌های لامبدا که از یک بلوک دستور بهره می‌برند، بگذارید. متدهای بومی می‌توانند پیمایشگر (iterators) یا ناهمزمان (asynchronous) باشند.


### متدهای بومی ایستای (Static local methods)
افزودن پالایشگر `static` به یک متد بومی (از C# 8) از دیدن متغیرهای بومی و پارامترهای متد دربرگیرنده توسط آن، پیشگیری کند.
این کار به کاستن همبستگی کمک کرده و از ارجاع ناخواسته متد بومی به متغیر های متد دربرگیرنده جلوگیری میکند.

نمونه : 
```Cs
static int CalculateSquare(int n)
{
    // متد بومی ایستای برای محاسبه مربع
    static int Square(int x)
    {
        return x * x;
    }

    return Square(n);

    //یا به صورت خلاصه تر : 
    static int Square(int x) => return x * x;
}
```

### متدهای بومی و دستورهای سطح-بالا(Top-level statements)
هر متدی که در دستورهای سطح-بالا شناسایی کنید، یک متد بومی شمرده میشود.
این بدان معناست که (اگر با `static` نشان‌گذاری نشده باشد)
میتوانید به متغیرهای دروندستورهای سطح-بالا دسترسی داشته باشید : 
```Cs
int x = 3;
void Foo() => Console.WriteLine(x);
```

### پربارسازی متدها (Overloading methods)
متدهای بومی نمی‌توانند پربارسازی شوند. این بدان معناست که متدهای که در دستور های سطح-بالا شناسایی شده‌اند(که متدهای بومی شمرده میشوند) نمی توانند پربارسازی شوند.

یک گونه می‌تواند متدها را پربارسازی کند(چند متد با نام یکسان شناسایی کند) تا زمانی که امضاها ناهمسان باشند.
برای نمونه، همه‌ی متدهای زیر میتوانند در یک گونه همزیستی داشته باشند:
```Cs
void Foo (int x){}
void Foo(double x){}
void Foo (int x , float y){}
void Foo(float x, int y){}
```

با این همه، جفت متدهای زیر نمی‌توانند در یک گونه همزیستی داشته باشند، زیرا گونه‌ی بازگشتی و پالایشگر `params` بخشی از امضای یک متد نیستند:
```Cs
void Foo (int x) {}
float Foo (int x) {} 

void Goo (int[] x) {}
void Goo (params int[] x) {} 
```

این که یک پارامتر با ارزش می‌گذرد یا با ارجاع، نیز بخشی از امضا است.
برای نمونه، `Foo(int)` می‌تواند با `Foo(ref int)` یا `Foo(out int)` همزیستی داشته باشد. با این همه، `Foo(ref int)` و `Foo(out int)` نمی‌توانند همزیستی داشته باشند:
```Cs
void Foo (int x) {}
void Foo (ref int x) {}
void Foo (out int x) {} 
```


### سازنده‌های نمونه‌ای (Instance Constructors)
سازنده‌ها کد آغازگری را در یک کلاس یا ساختار به کار می‌اندازند. یک سازنده مانند یک متد شناسایی می‌شود، جز اینکه نام متد و گونه‌ی بازگشتی به نام گونه‌ی دربرگیرنده کاهش می‌یابد:
```Cs
Panda p = new Panda ("Petey");

public class Panda
{
 string name;
 public Panda (string n)
 {
 name = n;
 }
}
```
سازنده های نمونه‌ای اجازه‌ی به‌کارگیری پالایشگرهای زیر را میدهند :
- پالایشگرهای دسترسی (Access modifiers)
`public internal private protected`
- پالایشگرهای کد بی‌مدیریت (Unmanaged code modifiers)
`unsafe extern`

سازنده های تک دستوری نیز میتوانند به عنوان اندام های بیان-پیکر نوشته شوند: 
```Cs
public Panda (string n) => name = n;
```
اگر نام یک پارامتر(یا هر نام متغیر دیگری) با نام یک فیلد هم‌پوشانی داشته باشد، میتوانید با پیشوند `this` فیلد را از هم باز شناسید:
```Cs
public Panda (string name ) => this.name = name;
```
برای نمونه  بهتر :
```Cs
public class LearnCsharp{
    public string name = "";

    public Panda(string name) => this.name = name;
    //در اصل نام اولی به فیلد اشاره میکند و دومی به پارامتر در  متد
}
```

### پربارسازی سازنده‌ها(Overloading constructors)
یک کلاس یا ساختار میتواند سازنده‌ها را پربارسازی کند.
برای پرهیز از تکرار کد(که خیلی مهم است )، یک سازنده میتواند سازنده‌ی دیگری را با بهره‌گیری از کلیدواژه‌ی `this` فراخوانی کند :
```Cs
public class Wine{
    public decimal Price;
    public int Year;
    public Wine (decimal price) => Price = price;
    public Wine (decimal price, int year) : this (price) => Year = year;    
}
```
زمانی که یک سازنده، دیگری را فراخوانی میکند، سازنده‌ی فراخوانده شده نخست اجرا میشود.

شما میتوانید یک بیان (expression) را به درون سازنده‌ی دیگر بفرستید، به گونه ای که در زیر آمده است :
```Cs
public Wine (decimal price, DateTime year) : this (price, year.Year) { }
```

این بیان می‌تواند به اندام های ایستا (static) کلاس دسترسی داشته باشد، اما به اندام های نمونه ای(instance) نه.

این نمونه‌ی ویژه میتواند به گونه‌ای بهتر با یک سازنده‌ی تکی که سال را به عنوان یک پارامتر دلخواه(optional) دارد ، پیاده سازی شود :
```Cs
public Wine (decimal price, int year = 0)
{
    Price = price; Year = year;
}
```


### سازنده‌های بدون پارامتر ضمنی (Implicit parameterless constructors)
برای کلاس‌ها گردآورنده‌ی C# به خودی خود یک سازنده‌ی بدون پارامتر `public` را تنها زمانی پدید می آورد که شما هیچ سازنده‌ای را شناسایی نکرده باشید.
با این همه ، به محض این که دست کم یک سازنده‌ را شناسایی کنید آن سازنده‌ی بدون بدون پارامتر دیگر به خودی خود پدیدار نمی‌شود.

برای درک بهتر این موضوع : 

```Cs
public class MyClass
{
}

MyClass obj1 = new MyClass();

public class MyClassWithConstructor
{
    public MyClassWithConstructor(int value)
    {
    }
}

MyClassWithConstructor obj2 = new MyClassWithConstructor(10);
```
به این معناست :
در زبان C#، اگر شما یک کلاس را تعریف کنید و هیچ سازنده‌ای برای آن مشخص نکنید، کامپایلر به طور خودکار یک سازنده‌ی بدون پارامتر (Implicit parameterless constructor) برای آن کلاس ایجاد می‌کند. اما اگر شما یک سازنده‌ی دیگر (مثلاً با پارامتر) تعریف کنید، آن سازنده‌ی بدون پارامتر دیگر به طور خودکار ایجاد نخواهد شد.


### ترتیب آغازگری سازنده و فیلد (Constructor and field initialization)
پیش از این دیدیم که فیلد‌ها می توانند با ارزش های پیش گزیده در شناسایی شان، آغاز گردنند:
```Cs
class player{
    int shields = 50;
    int health = 100;
}
```
آغازگری فیلدها پیش از اجرای سازنده و به ترتیب شناسایی فیلدها ، رخ میدهد

### سازنده‌های غیرهمگانی (Nonpublic constructors)
سازنده ها نیاز نیست `public` باشند.
یک شوند همگانی برای داشتن یک سازنده‌ی غیرهمگانی، چیره شدن بر پدیدآوری نمونه از راه یک فراخوانی متد `static` است. متد `static` می‌تواند برای بازگرداندن یک شیء از یک استخر (pool)، به جای پدیدآوری یک شیء نو، یا برای بازگرداندن زیرکلاس‌های گوناگون بر پایه‌ی آرگومان‌های ورودی به کار رود:

```Cs
public class Class1
{
 Class1() {}
 public static Class1 Create (...)
 {
 // Perform custom logic here to return an instance of Class1
 }
}
```

### پادسازنده‌ها (Deconstructors)
یک پادسازنده (که با نام "متد پادسازنده" نیز خوانده میشود) کارکردی درست برعکس یک سازنده دارد :
درحالی که یک سازنده به گونه‌ای همگانی یک سری از ارزش‌ها را (به عنوان پارامتر) می‌گیرد و به فیلدها می‌سپارد، یک پادسازنده کار برعکس را انجام می دهد و فیلدها را به  یک سری از متغیر ها میسپارد.

یک متد پادسازنده باید `Deconstruct` نامیده شود و باید یک یا چند پارامتر `out` داشته باشد، مانند نمونه زیر : 

```Cs
class Rectangle{
     public readonly float Width, Height;
    
    public Rectangle (float width, float height)
    {
        Width = width;
        Height = height;
    }
    
    
    public void Deconstruct (out float width, out float height)
    
    {
    
    width = Width;
    
    height = Height;
    
    }
}

```

دستور ویژه زیر ، پادسازنده را فراخوانی میکند:
```Cs
var rect = new Rectangle (3, 4);
(float width, float height) = rect; // پادسازی
Console.WriteLine (width + " " + height); // 3 4
```

سطر دوم، فراخوانی پادسازی است، . این سطر ، دو متغیر بومی را می‌سازد و سپس متد `Deconstruct` را فراخوانی میکند. 
فراخوانی پادسازی ما به نمونه‌ی زیر هم ارز است : 
```Cs
float width , height;
rect.Deconstruct(out width , out height);
```
یا :
```Cs
(var width, var height) = rect;
```

یا به سادگی به این گونه :
```Cs
var (width, height) = rect;
```

اگر به یک یا چند متغیر بی‌میل هستید ، می توانید از نماد دورریز(`_`) سی شارپ بهره ببرید : 
```Cs
var (_ , height) = rect;
```

این کار، به درستی نیت شما را نسبت به شناسایی یک متغیر که هرگز از آن بهره نمی برید  را نشان میدهد.

اگر متغیرهایی که در آن ها پادسازی می کنید از پیش شناسایی شده اند، می توانید گونه‌ها را به کلی نادیده بگیرید : 

```Cs
float width, height;
(width, height) = rect;
```

این کار، واگذاری پادسازی (**deconstructing assignment**) نامیده می‌شود. شما می‌توانید از یک واگذاری پادسازی برای ساده‌تر کردن سازنده‌ی کلاس خود بهره ببرید:

```Cs
public Rectangle (float width, float height) =>
 (Width, Height) = (width, height);
```

شما می‌توانید با پربارسازی متد `Deconstruct،` گزینه‌های گوناگونی برای پادسازی به فراخواننده پیشکش کنید.

متد `Deconstruct` می‌تواند یک متد گسترشی (**extension method**) باشد. این کار یک ترفند کارآمد است اگر می‌خواهید گونه‌هایی را پادسازی کنید که شما نویسنده‌ی آن‌ها نبوده‌اید.

از **سی‌شارپ 10**، می‌توانید متغیرهای از پیش موجود و متغیرهای نو را زمانی که پادسازی می‌کنید، با هم درآمیزید:

```Cs
double x1 = 0;
(x1, double y2) = rect;
```


### آغازگرهای شیء (Object Initializers)

برای ساده‌ترک ردنآغازگری شیء، هر فیلد یا ویژگی(`property`) دسترسی پذیر یک شیء میتوانید از راه یک **آغازگر شیء** ، درست  پس از ساخت ، مقداردهی شود. برای نمونه ، کلاس زیر را در نظر بگیرید : 

```Cs
public class Bunny
{
    public string Name;
    public bool LikesCarrots, LikesHumans;
    public Bunny () {}
    public Bunny (string n) => Name = n;
}
```

با بهره‌گیری از آغازگرهای شیء، میتوانید نمونه های کلاس `Bunny` را به این گونه پدید آورید : 

```Cs
// به یاد داشته باشید که سازنده‌های بدون پارامتر می‌توانند پرانتزهای خالی را نادیده بگیرند
Bunny b1 = new Bunny { Name="Bo", LikesCarrots=true, LikesHumans=false };
Bunny b2 = new Bunny ("Bo") { LikesCarrots=true, LikesHumans=false };
```

کد برای ساخت `b1` و `b2` با کد زیر هم‌ارز است:
```Cs
Bunny temp1 = new Bunny();
temp1.Name = "Bo";
temp1.LikesCarrots = true;
temp1.LikesHumans = false;
Bunny b1 = temp1;

Bunny temp2 = new Bunny ("Bo");
temp2.LikesCarrots = true;
temp2.LikesHumans = false;
Bunny b2 = temp2;
```
متغیرهای موقت برای این هستند که اگر در زمان آغازگری، یک کژکاری (`exception`) رخ دهد، شما یک شیء نیمه‌آغازگری‌شده نداشته باشید.


> ### آغازگرهای شیء در برابر پارامترهای دلخواه (Optional Parameters)
>
> به جای وابستگی به آغازگرهای شیء، می‌توانستیم سازنده‌ی `Bunny` را به گونه‌ی زیر، با یک پارامتر بایسته (`mandatory`) و دو پارامتر دلخواه، بنویسیم:
> 
> ```csharp
> public Bunny (string name,
>  bool likesCarrots = false,
>  bool likesHumans = false)
> {
>  Name = name;
>  LikesCarrots = likesCarrots;
>  LikesHumans = likesHumans;
> }
> ```
> 
> این کار به ما پروانه‌ی ساخت یک `Bunny` را به این گونه می‌داد:
> 
> ```csharp
> Bunny b1 = new Bunny (name: "Bo",
>  likesCarrots: true);
> ```
> 
> به گونه‌ای تاریخی، وابستگی به سازنده‌ها برای آغازگری شیء، سودمند بود؛ چرا که به ما پروانه‌ی خواندنی-تنها کردن فیلدها (یا ویژگی‌های) `Bunny` را می‌داد. خواندنی-تنها کردن فیلدها یا ویژگی‌ها، یک شیوه‌ی نیکو است زمانی که هیچ چرایی برای دگرگونی آن‌ها در سراسر زندگی شیء نیست. با این همه، همان گونه که در آینده در گفتگو درباره‌ی ویژگی‌ها خواهیم دید، پالایشگر `init` که در سی‌شارپ 9 پدیدار شد، به ما پروانه‌ی رسیدن به این هدف را با آغازگرهای شیء می‌دهد.
>
> پارامترهای دلخواه، دو کاستی دارند. نخست این که در حالی که بهره‌گیری از آن‌ها در سازنده‌ها به گونه‌های خواندنی-تنها پروانه می‌دهد، به آسانی به دگرگونی‌های غیرمخرب (`nondestructive mutation`) پروانه نمی‌دهند. (درباره‌ی دگرگونی‌های غیرمخرب و راه‌کار این دشواری، در آینده خواهیم گفت).
>
> دومین کاستی پارامترهای دلخواه این است که زمانی که در کتابخانه‌های همگانی به کار می‌روند، جلوی سازگاری با نسخه‌های پیشین را می‌گیرند. این به آن شوند است که افزودن یک پارامتر دلخواه در آینده، سازگاری دودویی (`binary compatibility`) اسمبلی را با فراخوانندگان از پیش موجود از بین می‌برد.
>
> دشواری از این جاست که هر ارزش پارامتر دلخواه در فراخوانی‌گاه (`calling site`) پخته می‌شود. به سخن دیگر، سی‌شارپ، فراخوانی سازنده‌ی ما را به این گونه برمی‌گرداند:
> 
> ```csharp
> Bunny b1 = new Bunny ("Bo", true, false);
> ```
> 
> این کار پرمسئله است اگر ما نمونه‌ی `Bunny` را از یک اسمبلی دیگر بسازیم و در آینده با افزودن یک پارامتر دلخواه دیگر مانند `likesCats`، `Bunny` را دگرگون کنیم. اگر اسمبلی ارجاع‌دهنده دوباره گردآوری (`recompiled`) نشود، همچنان به فراخوانی سازنده‌ی (که اکنون نیست) با سه پارامتر ادامه می‌دهد و در زمان اجرا شکست می‌خورد.


## رجاع `this` (The `this` Reference)

ارجاع `this` به خود نمونه اشاره دارد. در نمونه‌ی زیر، متد `Marry` از `this` بهره می‌برد تا فیلد `mate` همراه را مقداردهی کند:
```cs
public class Panda
{
    public Panda Mate;
    public void Marry (Panda partner)
    {
        Mate = partner;
        partner.Mate = this;
    }
}
```
ارجاع `this` همچنین یک متغیر بومی یا پارامتر را از یک فیلد باز می‌شناساند؛ برای نمونه:
```cs
public class Test
{
    string name;
    public Test (string name) => this.name = name;
}
```
ارجاع `this` تنها در درون اندام‌های غیرایستای یک کلاس یا ساختار، کارآمد است.

### ویژگی‌ها (Properties)

ویژگی‌ها (`Properties`) از بیرون مانند فیلدها (`fields`) به نظر می‌رسند، اما در درون، آن‌ها همانند متدها (`methods`) دارای کارکرد (logic) هستند. برای نمونه، شما با نگاه کردن به کد زیر نمی‌توانید بگویید که `CurrentPrice` یک فیلد است یا یک ویژگی:


```Cs
Stock msft = new Stock();
msft.CurrentPrice = 30;
msft.CurrentPrice -= 3;
Console.WriteLine (msft.CurrentPrice);
```

یک ویژگی همانند یک فیلد اعلان میشود اما با یک بلوک `get` , `set` که به آن افزودهشده است.
این هم چگونگی پیاده‌سازی `CurrentPrice` به عنوان یک ویژگی : 

```Cs
public class Stock
{
    decimal currentPrice; // فیلد "پشتیبان" خصوصی (private "backing" field)
    public decimal CurrentPrice // ویژگی همگانی (public property)
    {
        get { return currentPrice; }
        set { currentPrice = value; }
    }
}
```

`get` و `set` نشان‌دهنده‌ی **دسترسی‌سازهای ویژگی (property accessors)** هستند. دسترسی‌ساز `get` زمانی اجرا می‌شود که ویژگی خوانده می‌شود. این دسترسی‌ساز باید یک ارزش از گونه‌ی ویژگی را بازگرداند. دسترسی‌ساز `set` زمانی اجرا می‌شود که ویژگی مقداردهی می‌شود. این دسترسی‌ساز یک پارامتر ضمنی با نام `value` از گونه‌ی ویژگی دارد که شما به گونه‌ای همگانی آن را به یک فیلد خصوصی (در این نمونه، `currentPrice`) می‌سپارید.

گرچه به ویژگی‌ها به همان شیوه‌ی فیلدها دسترسی می‌یابند، اما آن‌ها در این که به پیاده‌ساز، کنترل کاملی بر روی گرفتن و سپردن ارزششان می‌دهند، با هم دگرسانی دارند. این کنترل به پیاده‌ساز پروانه می‌دهد تا هر بازنمایی درونی (internal representation) که نیاز است را گزینش کند، بدون این که جزئیات درونی را به کارگیر ویژگی نمایش دهد. در این نمونه، متد `set` می‌تواند یک کژکاری (exception) را پرتاب کند اگر `value` بیرون از یک بازه‌ی درست باشد.

> در سراسر این کتاب، ما از فیلدهای همگانی به گونه‌ای گسترده بهره می‌بریم تا نمونه‌ها از پریشانی دور بمانند. در یک نرم‌افزار راستین، شما به گونه‌ای همگانی، ویژگی‌های همگانی را بر فیلدهای همگانی برتر می‌شمارید تا **کپسوله‌سازی (encapsulation)** را ترویج کنید.

ویژگی‌ها اجازه‌ی به‌کارگیری پالایشگرهای (modifiers) زیر را می‌دهند:
* **پالایشگر ایستا (Static modifier)**
  `static`
* **پالایشگرهای دسترسی (Access modifiers)**
  `public internal private protected`
* **پالایشگرهای ارث‌بری (Inheritance modifiers)**
  `new virtual abstract override sealed`
* **پالایشگرهای کد بی‌مدیریت (Unmanaged code modifiers)**
  `unsafe extern`



### ویژگی‌های خواندنی-تنها و محاسبه شده (Read-only and calculated properties)
یک ویژگی، **خواندنی-تنها (read-only)** است اگر تنها یک دسترسی‌ساز `get` را شناسایی کند و **نوشتنی-تنها (write-only)** است اگر تنها یک دسترسی‌ساز `set` را شناسایی کند. ویژگی‌های نوشتنی-تنها به ندرت به کار می‌روند.

یک ویژگی به گونه‌ای همگانی یک **فیلد پشتیبان (backing field)** ویژه برای نگهداری داده‌های زیربنایی دارد. با این همه، یک ویژگی می‌تواند از داده‌های دیگر نیز محاسبه شود:

```Cs
decimal currentPrice, sharesOwned;
public decimal Worth
{
    get { return currentPrice * sharesOwned; }
}

```


### ویژگی‌های بیان-پیکر (Expression-bodied properties)
شما می‌توانید یک ویژگی خواندنی-تنها (readonly) مانند نمونه‌ی پیشین ، را به گونه‌ای کوتاه‌تر به عنوان یک ویژگی بیان-پیکر (expression-bodied property) شناسایی کنید. یک پیکان فربه (=>) جای همه‌ی آکولادها و کلیدواژه های `get` و `return` را می گیرد:
```Cs
public decimal Worth => currentPrice * sharesOwned;
```
با یک ساختار نوشتاری (syntax) کمی بیشتر ، دسترسی سازهای `set` نیز میتوانند بیان-پیکر باشند : 
```Cs
public decimal Worth
{
    get => currentPrice * sharesOwned;
    set => sharesOwned = value / currentPrice;
}

```

### ویژگی های خودکار (Automatic properties)

همگانی ترین پیاده سازی برای یک ویژگی، یک `getter` و یا `setter` است که به سادگی یک فیلد خصوصی با همان گونه‌ی ویژگی را می خواند و می نویسد. یک شناسایی ویژگی خودکار ، به گردآورنده(compiler) دستور می‌دهد که این پیاده‌سازی را فراهم کند.
ما میتوانیم نخستین نمونه‌ی این بخش را با شناسایی `CurrentPrice` به عنوان یک ویژگی خودکار، بهتر کنیم :
```Cs
public class Stock
{
    // ...
    public decimal CurrentPrice { get; set; }
}
```
گردآورنده به گونه‌ای خودکار یک **فیلد پشتیبان خصوصی (private backing field)** با یک نام گردآورنده-ساخته که نمی توان به آن اشاره کرد ، پدید می‌آورد. 
دسترسی ساز `set` می تواند به عنوان `private` یا `protected` نشان‌گذاری شود ،
اگر می خواهید ویژگی را به گونه‌ی خواندنی-تنها (readonly) به گونه‌های دیگر نمایش دهید .
ویژگی های خودکار در سی شارپ 3 پدیدار شدند.


**پی نوشت مترجم :**
برای درک بهتر موضوع بالا یک نمونه کوچک مینویسم :
اگر بخواهید یکی از ویژگی‌ها را به صورت خواندنی-تنها تعریف کنید، می‌توانید فقط یک `getter` تعریف کنید و `setter` را حذف کنید:
```Cs
public class Stock
{
    // ویژگی خودکار برای قیمت جاری
    public decimal CurrentPrice { get; set; }

    // ویژگی خواندنی-تنها برای نام شرکت
    public string CompanyName { get; }

    // سازنده برای مقداردهی اولیه نام شرکت
    public Stock(string companyName)
    {
        CompanyName = companyName;
    }
}
```
و ویژگی های Automatic properties در سی شارپ یک ویژگی خوب است که در متن های قبلی هم در بخش سازنده ها هم به چشم خورد. که در آنجا با نام (Auto-implemented Constructors) دیدیم.



### آغازگرهای ویژگی (Property initializers)

شما میتوانید یک آغازگر ویژگی را به ویژگی  های خودکار، همانند فیلدها ، بیفزایید:

```Cs
public decimal CurrentPrice { get; set; } = 123;
```
این کار به `CurrentPrice` یک ارزش آغازین 123 میدهد.
ویژگی‌هایی که دارای یک آغازگر هستند، می‌توانند خواندنی-تنها باشند : 
```Cs
public int Maximum { get; } = 999;
```
درست همانند فیلدهای خواندنی-تنها (یا فقط-خواندنی)، ویژگی های خودکار خواندنی-تنها نیز می‌توانند در سازنده‌ی گونه، مقداردهی شوند.
این کار در ساخت گونه‌های تغییرناپذیر(`immutable`) سودمند است.

#### دسترسی get و set
دسترسی سازهای `get` و `set` می‌توانند سطح های دسترسی گوناگونی داشته باشند.
کارکرد همگانی برای این کار، داشتن یک ویژگی همگانی با یک پالایشگر دسترسی `internal` یا `private` بر روی `setter` است :

```Cs
public class Foo
{
    private decimal x;
    public decimal X
    {
        get { return x; }
        private set { x = Math.Round (value, 2); }
    }
}
```

به یاد داشته باشید که شما خود ویژگی را با سطح دسترسی پروانه دارتر (در این نمونه `public`) شناسایی میکنید و پالایشگر را به دسترسی‌سازی که میخواهید دسترسی کمتری داشته باشد ، می افزایید.

### دسترسی سازهای تنها-آغازگر(Init-only setter)
از سی شارپ 9، شما می توانید یک دسترسی ساز ویژگی را با `init` به جای `set` شناسایی کنید :

```Cs
public class Note
{
    public int Pitch { get; init; } = 20; // ویژگی "تنها-آغازگر"
    public int Duration { get; init; } = 100; // ویژگی "تنها-آغازگر"
}
```

این ویژگی های تنها-آغازگر (init-only properties) مانند ویژگی های خواندنی-تنها کار میکنند،
با این دگرسانی(تفاوت) که می‌توانند از راه یک **آغازگر شیء (object initializer)** نیز مقدار دهی شوند :
```Cs
var note = new Note { Pitch = 50 };
```

پس از آن ویژگی نمی تواند دگرگون (تغییر) شود :
```Cs
note.Pitch = 200; // کژکاری – دسترسی‌ساز تنها-آغازگر!
```

ویژگی‌های تنها-آغازگر حتی از درون کلاس خود نیز نمی توانند مقداردهی شوند، مگر از راه آغازگر ویژگی ، سازنده ، یا یک دسترسی ساز تنها-آغازگر دیگر این کار انجام شود.

راه جایگزین برای ویژگی های تنها-آغازگر، داشتن ویژگی های خواندنی-تنها است که آن ها را از راه یک سازنده، پر می کنید:

```Cs
public class Note
{
    public int Pitch { get; }
    public int Duration { get; }
    public Note (int pitch = 20, int duration = 100)
    {
        Pitch = pitch; Duration = duration;
    }
}

```

اگر کلاس بخشی از یک کتابخانه‌ی همگانی باشد، این شیوه سازگاری نسخه‌ها را دشوار می‌کند، چرا که افزودن یک پارامتر دلخواه به سازنده در آینده، سازگاری دودویی (`binary compatibility`) را با فراخوانندگان می‌شکند (در حالی که افزودن یک ویژگی تنها-آغازگر نو، چیزی را نمی‌شکند).

ویژگی‌های تنها-آغازگر یک سودمندی چشمگیر دیگر نیز دارند، که آن این است که آن‌ها به دگرگونی غیرمخرب (`nondestructive mutation`) پروانه می‌دهند، زمانی که همراه با رکوردها (`records`) به کار می‌روند.

همانند دسترسی‌سازهای `set` معمولی، دسترسی‌سازهای تنها-آغازگر نیز می‌توانند یک پیاده‌سازی را فراهم کنند:
```Cs
public class Note
{
    readonly int _pitch;
    public int Pitch { get => _pitch; init => _pitch = value; }
    // ...
}
```

به یاد داشته باشید که فیلد `_pitch` خواندنی-تنها است: به دسترسی‌سازهای تنها-آغازگر پروانه داده می‌شود تا فیلدهای خواندنی-تنهای کلاس خودشان را دگرگون کنند. (بدون این ویژگی، `_pitch` نیاز به نوشتنی بودن داشت، و کلاس در درونی تغییرناپذیر بودن شکست می‌خورد).

دگرگون کردن دسترسی‌ساز یک ویژگی از `init` به `set` (یا برعکس) یک دگرسانی شکننده دودویی **(binary breaking change)** است: هر کسی که به `اسمبلی` شما ارجاع دهد، باید `اسمبلی` خود را دوباره گردآوری کند.

این نباید زمانی که گونه‌های کاملاً تغییرناپذیر می‌سازید، یک مسئله باشد، چرا که گونه‌ی شما هرگز به ویژگی‌هایی با دسترسی‌ساز `set` (نوشتنی) نیاز نخواهد داشت.


### پیاده‌سازی ویژگی CLR

دسترسی‌سازهای ویژگی سی‌شارپ به گونه‌ی درونی به متدهایی با نام‌های `get_XXX` و `set_XXX` گردآوری می‌شوند:
```Cs
public decimal get_CurrentPrice {...}
public void set_CurrentPrice (decimal value) {...}
```

یک دسترسی‌ساز `init` مانند یک دسترسی‌ساز `set` پردازش می‌شود، اما با یک پرچم افزوده که در فرا داده‌های modreq دسترسی‌ساز set کدگذاری شده است.
دسترسی‌سازهای ویژگی غیرمجازی (`nonvirtual`) و ساده، از راه گردآورنده‌ی `JIT (Just-In-Time) `درون‌خطی (`inlined`) می‌شوند، که هر دگرسانی کارایی میان دسترسی به یک ویژگی و یک فیلد را از بین می‌برد. درون‌خطی‌سازی (`Inlining`) یک بهینه‌سازی است که در آن یک فراخوانی متد با بدنه‌ی آن متد جایگزین می‌شود.


### ایندکسرها (Indexers)

ایندکسرها (Indexers) ساختاری نوشتاری (syntax) سر راست را برای دسترسی به اندام‌ها (elements) در یک کلاس (class) یا ساختار(struct) فراهم میکنند که یک فهرست (list) یا واژه‌نامه(dictionary) از ارزش‌ها را کپسوله سازی می کنند.
 ایندکسرها مانند ویژگی‌ها هستند، اما از راه یک آرگومان اندیس (`index argument`) به جای یک نام ویژگی، به آن‌ها دسترسی پیدا می‌شود. کلاس `string` یک ایندکسر دارد که به شما پروانه می‌دهد به هر یک از ارزش‌های `char` آن از راه یک اندیس `int` دسترسی یابید:
 ```Cs
 string s = "hello";
Console.WriteLine (s[0]); // 'h'
Console.WriteLine (s[3]); // 'l'
```

ساختار نوشتاری برای بهره‌کیری از ایندکسرها ، ماننده  بهره‌گیری از آرایه‌ها است، با این دگرسانی که آرگومان(های) اندیس می‌تواند از هر گونه‌ای باشد.

ایندکسرها همان پالایشگرهایی (modifiers) را دارند که ویژگی‌ها دارند و می‌توانند به گونه‌ای با پرسشگر (null-conditionally) فراخوانی شوند، با افزودن یک علامت پرسش پیش از براکت مربع:

```Cs
string s = null;
Console.WriteLine (s?[0]); // چیزی نمی‌نویسد؛ کژکاری (error) ندارد.
```

#### پیاده‌سازی یک ایندکسر (Implementing an indexer)

برای نوشتن یک ایندکسر، یک ویژگی با نام `this` شناسایی کنید و آرگومان‌ها را در براکت‌های مربع بگذارید:
```Cs
class Sentence
{
    string[] words = "The quick brown fox".Split();
 
    public string this [int wordNum] // indexer
 
    {
 
        get { return words [wordNum]; }
 
        set { words [wordNum] = value; }
 
    }
}

```

این هم چگونگی بهره‌گیری از این ایندکسر:
```Cs
Sentence s = new Sentence();
Console.WriteLine (s[3]); // fox
s[3] = "kangaroo";
Console.WriteLine (s[3]); // kangaroo
```

یک گونه می‌تواند چندین ایندکسر را شناسایی کند که هر یک پارامترهایی از گونه‌های دگرسان دارند. یک ایندکسر همچنین می‌تواند بیش از یک پارامتر داشته باشد:

```Cs
public string this [int arg1, string arg2]
{
    get { ... } set { ... }
}

```

اگر دسترسی ساز `set` را نادیده بگیرید ، یک ایندکسر خواندنی-تنها می شود و می توانید از ساختار نوشتاری بیان-پیکر(expression-bodied syntax) برای کوتاه‌تر کردن شناسایی آن بهره ببرید:

```Cs
public string this [int wordNum] => words [wordNum];
```

#### پیاده‌سازی ایندکسر CLR (CLR indexer implementation)

ایندکسر ها به گونه‌ی درونی به متدهایی با نام های `get Item` و `set Item` به گونه‌ی زیر گردآوری می شوند:

```Cs
public string get_Item (int wordNum) {...}
public void set_Item (int wordNum, string value) {...}
```

### بهره‌گیری از اندیس‌ها و بازه‌ها با ایندکسرها (Using indices and ranges with indexers)

شما میتوانید با شناسایی یک ایندکسر با یک گونه‌ی پارامتری از `Index` یا `Range` از اندیس ها و بازه ها در کلاس های خود پشتیبانی کنید.
ما میتوانیم نمونه‌ی پیشین خود را با افزودن این ایندکسرها به کلاس `Sentence` گسترش بدیم:
```Cs
public string this [Index index] => words [index];
public string[] this [Range range] => words [range];
```
این کار ، نمونه‌ی زیر پروانه می دهد:
```Cs
Sentence s = new Sentence();
Console.WriteLine (s [^1]); // fox 
string[] firstTwoWords = s [..2]; // (The, quick)

```
> **پی نوشت مترجم**
> شاید کمی این بخش گیج کننده باشد یک نمونه خوب برای بهتر فهمیدن این ایندکسر ها :
> ```Cs
> public class MyDictionary
> {
>     private Dictionary<string, string> internalData = new Dictionary<string, string>();
> 
>     public string this[string key]
>     {
>         get { return internalData[key]; }
>         set { internalData[key] = value; }
>     }
> }
> ```
> و به این صورت میتوانیم از آن استفاده کنیم :
> ```Cs
> var myDict = new MyDictionary();
> myDict["سی شارپ"] = "یک زبان برنامه‌نویسی است";
> Console.WriteLine(myDict["سی شارپ"]);
> ```
> در اصل ایندکسر ها یک ابزار قدرتمند و قوی هستند که به ما این اجازه رو میدهند که یک کلاس یا > ساختار را مانند  یک آرایه یا واژه‌نامه(دیکشنری) با آن رفتار کنیم
>  به جای فراخوانی یک متد یا ویژگی برای دسترسی به اندام‌های درونی، می‌توانیم از نگارش [] بهره بگیریم.


### سازنده‌های اصلی (Primary Constructors) (C# 12)

از سی شارپ 12 ، شما میتوانید یک فهرست پارامتری را درست پس از شناسایی کلاس (یا ساختار) بگذارید:
```Cs
class Person (string firstName, string lastName)
{
    public void Print() => Console.WriteLine (firstName + " " + lastName);
}
```

این کار به گردآورنده (compiler) دستور می‌دهد  تا به گونه‌ی خودکار یک سازنده‌ی اصلی(primary constructor) را با بهره گیری از پارامترهای سازنده اصلی (`lastName` و `firstName`) بسازد تا ما بتوانیم کلاس خود را به گونه‌ی زیر نمونه سازی کنیم :
```Cs
Person p = new Person ("Alice", "Jones");
p.Print(); // Alice Jones
```

سازنده‌های اصلی برای نمونه سازی (prototyping) و دیگر سناریو های ساده سودمند هستند.
راه جایگزین این بود که فیلدها را شناسایی کرده و یک سازنده را به گونه‌ی آشکار بنویسیم :
```Cs
class Person // (بدون سازنده‌های اصلی)
{
    string firstName, lastName; // شناسایی فیلد
    public Person (string firstName, string lastName) // سازنده
    {
        this.firstName = firstName; // سپردن فیلد
        this.lastName = lastName; // سپردن فیلد
    }
    public void Print() => Console.WriteLine (firstName + " " + lastName);
}
```

سازنده‌ای که سیش ارپ می سازد ، اصلی خوانده میشود ، چرا که هر سازنده‌ی دیگری که شما به گونه‌ی آشکار بنویسید، باید آن را فراخوانی کند : 
```Cs
class Person (string firstName, string lastName)
{
    public Person (string firstName, string lastName, int age)
    : this (firstName, lastName) // باید سازنده‌ی اصلی را فراخوانی کند
    {
        // ...
    }
}

```
این کار تضمین می کند که پارامتر های سازنده اصلی همیشه پر می شوند.

> سی‌شارپ همچنین از رکوردها (**records**) پشتیبانی می‌کند. رکوردها نیز از سازنده‌های اصلی پشتیبانی می‌کنند؛ با این همه، گردآورنده یک گام افزوده با رکوردها برمی‌دارد و (به گونه‌ی پیش‌فرض) یک ویژگی **تنها-آغازگر** (**init-only**) همگانی برای هر پارامتر سازنده‌ی اصلی پدید می‌آورد. اگر این رفتار، دلخواه است، بهتر است به جای آن از رکوردها بهره ببرید.

سازنده های اصلی به دلیل محدودیت های زیر ، برای سناریو های ساده مناسب تر هستن :

- شما نمی توانید کد آغازگری افزوده به یک سازنده‌ی اصلی بیفزایید.

- اگرچه نشان دادن یک پارامتر سازنده‌ی اصلی به عنوان یک ویژگی همگانی ساده است، شما نمی‌توانید  به آسانی کارکرد (logic) پایش را در آن بگنجانید، مگر این که ویژگی خواندنی-تنها باشد.
 

سازنده های اصلی جایگزین سازنده‌ی بدون پارامتر پیش‌فرض می شوند که سی شارپ در غیر این صورت پدید می آورد.

### معنی‌شناسی سازنده‌ی اصلی (Primary constructor semantics)
برای درک این سازنده های اصلی چگونه کار میکنند ، ببنید که یک سازنده‌ی معمولی چگونه رفتار میکند :
```Cs
class Person
{
    public Person (string firstName, string lastName)
    {
        // ... do something with firstName, lastName
    }
}
```

زمانی که کد درون این سازنده به پایان میرسد ، پارامترهای `lastName` , `firstName` از دامنه(scope) بیرون می روند و نمی توان به آن‌ها دسترسی پیدا کرد. 
در برابر ، پارامتر های یک سازنده‌ی اصلی از دامنه بیرون نمی‌روند و می توان از هر جایی در کلاس، در سراسر زندگی شیء به آن‌ها دسترسی یافت.

- پارامتر های سازنده‌ی اصلی، سازه های ویژه‌ی سی شارپ هستند، نه فیلدها، گرچه گردآورنده (Compiler) در پس پرده، فیلدهای پنهانی را پدید می آورد تا ارزش های آن‌ها را در صورت نیاز ، نگه دارد.

### سازنده‌های اصلی و آغازگرهای فیلد/ویژگی (Primary constructors and field/property initializers)

دسترسی پذیری پارامترهای سازنده‌ی اصلی به آغازگرهای فیلد و ویژگی نیز گسترده می‌یاد. در نمونه‌ی زیر، ما از آغازگرهای فیلد و ویژگی بهره می بریم تا `firstName` را به یک فیلد همگانی و `lastName` را به یک ویژگی همگانی بسپاریم : 
```Cs
class Person (string firstName, string lastName)
{
    public readonly string FirstName = firstName; // فیلد
    public string LastName { get; } = lastName; // ویژگی
}
```

### پوشاندن پارامترهای سازنده‌ی اصلی (Masking primary constructor parameters)

فیلدها(یا ویژگی ها) می توانند نام پارامترهای سازنده‌ی اصلی را دوباره به کار ببرند:
```Cs
class Person (string firstName, string lastName)
{
    readonly string firstName = firstName;
    readonly string lastName = lastName;
    public void Print() => Console.WriteLine (firstName + " " + lastName);
}
```
در این سناریو، فیلد یا ویژگی برتری دارد و پارامتر سازنده‌ی اصلی را می پوشاند، مگر در سمت راست آغازگرهای فیلد و ویژگی.

- درست مانند پارامترهای معمولی، پارامترهای سازنده‌ی اصلی نیز نوشتنی هستند. پوشاندن آن‌ها با یک فیلد خواندنی-تنهای همنام (همانند نمونه‌ی ما) به گونه‌ای کارآمد از دگرگونی آن‌ها در آینده پاسداری می‌کند.

### پایش پارامترهای سازنده‌ی اصلی (Validating primary constructor parameters)
گاهی اوقات سودمند است که در  آغازگرهای (Initializer آغازگر) فیلد، یک حسابگری(computation) را انجام دهیم : 
```Cs
new Person ("Alice", "Jones").Print(); // Alice Jones
class Person (string firstName, string lastName)
{
    public readonly string FullName = firstName + " " + lastName;
    public void Print() => Console.WriteLine (FullName);
}
```
در نمونه‌ی بعدی ، ما یک نسخه بزرگ-حرف(حروف بزرگ) از lastName را به یک فیلد همنام میسپاریم(و ارزش پیشین را می پوشانیم):
```cs
new Person ("Alice", "Jones").Print(); // Alice JONES
class Person (string firstName, string lastName)
{
    readonly string lastName = lastName.ToUpper();
    public void Print() => Console.WriteLine (firstName + " " + lastName);
}
```

در آینده خواهیم گفت که چگونه کژکاری‌ها(Exception) را پرتاب کنیم.
این هم یک پیش نمونه برای نشان دادن این که چگونه می توان از این کار با سازنده‌های اصلی بهره بدر تا `lastName` را در زامن ساخت، پایش کنیم و مطمئن شویم که `null` نیست :
```Cs
new Person ("Alice", null); // throws ArgumentNullException
class Person (string firstName, string lastName)
{
    readonly string lastName = (lastName == null)
    ? throw new ArgumentNullException ("lastName")
    : lastName;
}

```

> (به یاد داشته باشید که کد درون یک آغازگر فیلد یا ویژگی زمانی اجرا می‌شود که شیء ساخته می‌شود، نه زمانی که به فیلد یا ویژگی دسترسی می‌یابند.)


در نمونه‌ی بعدی، ما یک پارامتر سازنده‌ی اصلی را به عنوان یک ویژگی خواندنی/نوشتنی نشان می‌دهیم:
```Cs
class Person (string firstName, string lastName)
{
    public string LastName { get; set; } = lastName;
}
```

افزودن پایش به این نمونه سرراست نیست، چرا که شما باید در دو جا آن را پایش کنید : 
در یک دسترسی‌ساز `set` ویژگی (که به گونه‌ی دستی پیاده سازی شده است) و در آغازگر ویژگی در این هنگام، بهتر است از میان‌بر سازنده‌های اصلی بگذریم و یک سازنده و فیلدهای پشتیبان را به گونه‌ی آشکار شناسایی کنیم.

### سازنده‌های ایستا (Static Constructors)
یک سازنده‌ی ایستا یک بار به ازای هر گونه (`type`) اجرا می شود ، 
نه یک بار به ازای هر نمونه (`instance`) یک گونه تنها می تواند یک سازنده‌ی ایستا را شناسایی کند،
و آن باید بدون پارامتر(`parameterless`) باشد و همان نام گونه را داشته باشد:
```Cs
class Test
{
    static Test() { Console.WriteLine ("Type Initialized"); }
}
```

زمان اجرا (`runtime`) به گونه‌ی خودکار، یک سازنده‌ی ایستا را درست پیش از به کارگیری گونه، فراخوانی میکند، 
دو چیز این کار را راه‌اندازی میکنند:


- نمونه‌سازی از گونه 

- دسترسی به یک عضو ایستا (static member) در گونه

تنها پالایشگرهای (modifiers) مجاز برای سازنده‌های ایستا ، `unsafe` و `extern` هستند.

> اگر یک سازنده‌ی ایستا یک کژکاری (Exception) رسیدگی نشده (unhandled) را پرتات کند. آن گونه برای تمام زندگی برنامه (application) غیرقابل استفاده می شود.

از سی شارپ9 ، شما همچنین می توانید  **آغازگرهای پیمانه (module initializers)** را شناسایی کنید که یک بار به ازای هر اسمبلی (assembly) (زمانی که اسمبلی برای نسختین بار بارگذاری می شود) اجرا می شود.
برای شناسایی یک آغازگر پیمانه ، یک متد `static void` بنویسید و سپس سرآیند(attribute)  `[ModuleInitializer]` را به آن متد بدهید : 

```Cs
[System.Runtime.CompilerServices.ModuleInitializer]
internal static void InitAssembly()
{
    // ...
}
```

### سازنده‌های ایستا و ترتیب آغازگری فیلدها

آغازگرهای فیلد ایستا، درست پیش از فراخوانی سازنده‌ی ایستا اجرا می‌شوند. اگر یک گونه، سازنده‌ی ایستا نداشته باشد، آغازگرهای فیلد ایستا درست پیش از به کارگیری گونه — یا هر زمان دیگری به خواست زمان اجرا — اجرا خواهند شد.

آغازگرهای فیلد ایستا به ترتیبی که فیلدها شناسایی شده‌اند، اجرا می‌شوند. نمونه‌ی زیر این را نشان می‌دهد. `X` به 0 و `Y` به 3 آغازگری می‌شود:
```Cs
class Foo
{
    public static int X = Y; // 0
    public static int Y = 3; // 3
}
```
اگر دو آغازگر فیلد را جابه‌جا کنیم ، هر دو فیلد به 3 آغازگری میشوند.
نمونه‌ی بعدی 0 و سپس 3 را چاپ می کند ،
زیرا آغازگر فیلدی که یک `Foo` را نمونه‌سازی می کند،
پیش از آن که  `X` به 3 آغازگری شود ، اجرا می شود :
```Cs
Console.WriteLine (Foo.X); // 3
class Foo
{
    public static Foo Instance = new Foo();
    public static int X = 3;
    Foo() => Console.WriteLine (X); // 0
}
```
اگر دو خط پررنگ را جابجا کنیم، نمونه 3 و سپس 3 را چاپ می‌کند.

### کلاس‌های ایستا (Static Classes)
یک کلاسی که با `static` نشان‌گذاری شده باشد، نمی‌تواند نمونه‌سازی (`instantiated`) شود یا از آن ارث‌بری (`subclassed`) شود و باید تنها از اعضای ایستا پدید آمده باشد. کلاس‌های `System.Console` و `System.Math` نمونه‌های خوبی از کلاس‌های ایستا هستند.


### پایانگرها (Finalizers)
پایانگرها متدهایی هستند که تنها در کلاس‌ها وجود دارند و پیش از آن که گردآورنده‌ی  زباله (garbage collector) حافظه را برای یک شیء بدون ارجاع(unreferenced) بازپس گیرد،
اجرا میشود.
ساختار نوشتاری برای یک پایانگر، نام کلاس است که با نماد `~` در آغاز آن می آید :
```Cs
class Class1
{
    ~Class1()
    {
        // ...
    }
}
```
این در واقع ساختار نوشتاری سی شارپ برای بازنویسی (overriding) متد `Finalize` از `Object` است و گردآورنده (compiler) آن را به شناسایی متد زیر گسترش می دهد :
```Cs
protected override void Finalize()
{
    // ...
    base.Finalize();
}
```
ما به گونه‌ی کامل درباره‌ی گردآوری زباله و پایانگرها خواهیم گفت.

شما می‌توانید پایانگرهای تک-دستور را با بهره‌گیری از ساختار نوشتاری بیان-پیکر (expression-bodied syntax) بنویسید:
```Cs
~Class1() => Console.WriteLine ("Finalizing");
```

> پی نوشت مترجم : پایانگرها تنها زمانی اجرا می‌شوند که گردآورنده‌ی زباله (GC) می‌خواهد حافظه‌ی آن کلاس را پاک کند.


### گونه‌ها و متدهای بخشی (Partial Types and Methods)
گونه‌های بخشی پروانه‌ی بخش‌بندی یک شناسایی (definition) گونه را می‌دهند — به گونه‌ای همگانی در چندین پرونده (file). یک سناریوی همگانی برای یک کلاس بخشی این است که به گونه‌ی خودکار از یک منبع دیگر (مانند یک الگوی (template) یا طراحی‌گر (designer) ویژوال استودیو) پدید می‌آید و با متدهای دستی افزوده می‌شود:

```Cs
// PaymentFormGen.cs - auto-generated
partial class PaymentForm { ... }

// PaymentForm.cs - hand-authored
partial class PaymentForm { ... }
```
هر شرکت‌کننده باید شناسایی `partial` را داشته باشد؛ نمونه‌ی زیر نادرست است:

```Cs
partial class PaymentForm {}
class PaymentForm {}
```
شرکت‌کنندگان نمی‌توانند اعضای ناسازگار داشته باشند. برای نمونه، یک سازنده با همان پارامترها، نمی‌تواند دوباره تکرار شود. گونه‌های بخشی به گونه‌ی کامل از سوی گردآورنده حل می‌شوند، به این معنی که هر شرکت‌کننده باید در هنگام گردآوری در دسترس باشد و باید در یک اسمبلی باشد.

شما می‌توانید یک کلاس پایه (base class) را در یک یا چندین شناسایی کلاس بخشی مشخص کنید، به شرطی که کلاس پایه، اگر مشخص شده باشد، یکی باشد. افزون بر این، هر شرکت‌کننده می‌تواند به گونه‌ی مستقل، میانجی‌ها (interfaces) را برای پیاده‌سازی مشخص کند. ما در آینده درباره‌ی کلاس‌های پایه و میانجی‌ها خواهیم گفت.

گردآورنده هیچ تضمینی در باره‌ی ترتیب آغازگری فیلدها در شناسایی‌های گونه‌ی بخشی نمی‌دهد.


### متدهای بخشی (Partial methods)

یک گونه‌ی بخشی می‌تواند دارای متدهای بخشی باشد. این متدها پروانه‌ی فراهم کردن قلاب‌های (hooks) قابل سفارشی‌سازی را برای نویسندگی دستی در یک گونه‌ی بخشی خودکار پدید آمده می‌دهند؛ برای نمونه:

```Cs
partial class PaymentForm // In auto-generated file
{
 ...
 partial void ValidatePayment (decimal amount);
}
partial class PaymentForm // In hand-authored file
{
 ...
 partial void ValidatePayment (decimal amount)
 {
 if (amount > 100)
 ...
 }
}
```


یک متد بخشی از دو بخش پدید آمده است: یک شناسایی و یک پیاده‌سازی. شناسایی به گونه‌ای همگانی از سوی یک پدیدآورنده‌ی کد (code generator) نوشته می‌شود و پیاده‌سازی به گونه‌ای همگانی به گونه‌ی دستی نوشته می‌شود. اگر یک پیاده‌سازی فراهم نشود، شناسایی متد بخشی گردآوری نمی‌شود (و کدی که آن را فراخوانی می‌کند نیز گردآوری نمی‌شود). این کار به کد خودکار پدید آمده پروانه می‌دهد که در فراهم کردن قلاب‌ها بخشنده باشد، بدون این که نگران سنگین شدن (bloat) باشد.

متدهای بخشی باید `void` باشند و به گونه‌ی ضمنی خصوصی (`private`) هستند. آن‌ها نمی‌توانند شامل پارامترهای `out` باشند.

### متدهای بخشی گسترش‌یافته (Extended partial methods)

متدهای بخشی گسترش‌یافته (از سی‌شارپ 9)، برای سناریوی پدید آوردن کد برعکس (reverse code generation scenario) طراحی شده‌اند، جایی که یک برنامه‌نویس قلاب‌هایی را شناسایی می‌کند که یک پدیدآورنده‌ی کد آن‌ها را پیاده‌سازی می‌کند. یک نمونه از جایی که این می‌تواند رخ دهد، با پدیدآورنده‌های سرچشمه (source generators) است، یک ویژگی Roslyn که به شما پروانه می‌دهد یک اسمبلی را به گردآورنده بدهید که به گونه‌ی خودکار بخش‌هایی از کد شما را پدید می‌آورد.

یک شناسایی متد بخشی، گسترش‌یافته است اگر با یک پالایشگر دسترسی آغاز شود:

```Cs
public partial class Test
{
    public partial void M1(); // Extended partial method
    private partial void M2(); // Extended partial method
}

```
بودن پالایشگر دسترسی تنها بر دسترسی‌پذیری اثر نمی‌گذارد: به گردآورنده می‌گوید که شناسایی را به گونه‌ای دگرسان پردازش کند.

متدهای بخشی گسترش‌یافته باید پیاده‌سازی داشته باشند؛ اگر پیاده‌سازی نشوند، از بین نمی‌روند. در این نمونه، `M1` و `M2` باید پیاده‌سازی داشته باشند، زیرا هر یک پالایشگرهای دسترسی (public و private) را مشخص کرده‌اند.

به دلیل این که آن‌ها از بین نمی‌روند، متدهای بخشی گسترش‌یافته می‌توانند هر گونه‌ای را بازگردانند و می‌توانند شامل پارامترهای `out` باشند:
```Cs
public partial class Test
{
    public partial bool IsValid (string identifier);
    internal partial bool TryParse (string number, out int result);
}
```

### عملگر nameof
عملگر `nameof` نام هر نماد (`symbol`) (گونه، عضو، متغیر، و ...) را به عنوان یک رشته (`string`) بازمی‌گرداند:
```Cs
int count = 123;
string name = nameof (count); // name is "count"
```

سودمندی آن نسبت به مشخص کردن یک رشته، بررسی گونه‌ی ایستا (static type checking) است. ابزارهایی مانند ویژوال استودیو می‌توانند ارجاع نماد را درک کنند، بنابراین اگر شما نام نماد مورد نظر را دگرگون کنید، همه‌ی ارجاع‌های آن نیز دوباره نام‌گذاری خواهند شد.

برای مشخص کردن نام یک عضو گونه (type member) مانند یک فیلد یا ویژگی، گونه را نیز بگذارید. این کار با هر دو عضو ایستا و نمونه‌ای کار می‌کند:
```Cs
string name = nameof (StringBuilder.Length);
```
این به Length ارزیابی می‌شود. برای بازگرداندن `StringBuilder.Length`، شما باید این کار را 
انجام دهید:
```Cs
nameof (StringBuilder) + "." + nameof (StringBuilder.Length);
```

## ارث‌بری (Inheritance)

یک کلاس می تواند از کلاس دیگری ارث‌بری کند تا کلاس اصلی را گسترش(extend) یا سفارشی سازی(customize) کند.
ارث بری از یک کلاس به شما پروانه می دهد تا کارکرد (functionality ) آن کلاس را دوباره به کار ببرید.
به ای اینکه آن را از پایه بسازید.
یک کلاس می تواند تنها از یک کلاس ارث‌بری کند، اما خودش می تواند از سوی چندین کلاس ‌ارثبری شود.
بدون گونه یک **سلسله مراتب کلاس (class hierarchy)** را پدید می‌آورد.
در این نمونه ، ما با شناسایی یک کلاس به نام `Asset` آغاز میکنیم : 
```Cs
public class Asset{
    public string Name;
}
```
سپس، کلاس هایی به نام `Stock` و `House` را شناسایی می کنیم که از `Asset` ارث‌بری خواهند کرد.
`Stock` و `House` هر آنچه در `Asset` دارد را به دست می آورند.
به همراه هر عضو (member) افزوده‌ای که خود شناسایی میکنند:
```Cs
public class Stock : Asset // از Asset ارث‌بری می‌کند
{
    public long SharesOwned;
}
public class House : Asset // از Asset ارث‌بری می‌کند
{
    public decimal Mortgage;
}
```
این هم چگونگی بهره‌گیری از این کلاس‌ها :
```Cs
Stock msft = new Stock { Name="MSFT",
SharesOwned=1000 };
Console.WriteLine (msft.Name); // MSFT
Console.WriteLine (msft.SharesOwned); // 1000

House mansion = new House { Name="Mansion",
 Mortgage=250000 };
Console.WriteLine (mansion.Name); // Mansion
Console.WriteLine (mansion.Mortgage); // 250000
```

کلاس‌های مشتق‌شده (derived classes)، `Stock` و `House،` فیلد `Name` را از کلاس پایه (base class)، `Asset`، ارث‌بری می‌کنند.
یک کلاس مشتق‌شده، زیرکلاس (`subclass`) نیز خوانده می‌شود.
یک کلاس پایه، بالاکلاس (`superclass`) نیز خوانده می‌شود.

### چندریختی (Polymorphism)
ارجاع‌ها (references) چندریخت(polymorphic) هستند.
این بدان معناست که یک متغیر از گونه‌ی `x` می تواند به شیئی اشاره کند که زیرکلاس `x` است .
برای نمونه، متد زیر را در نظر بگیرید : 
```Cs
public static void Display (Asset asset)
{
    System.Console.WriteLine (asset.Name);
}
```
این متد می تواند هم یک `Stock` و هم یک `House` را نمایش دهد ، 
چرا که هر دو از `Asset` هستند : 

```Cs
Stock msft = new Stock ... ;
House mansion = new House ... ;
Display (msft);
Display (mansion);
```

چندریختی بر این پایه کار میکند که زیرکلاس‌ها (`Stock`و `House`) همه‌ی ویژگی های کلاس پایه‌ی خود (`Asset`) را دارند.
با این همه، برعکس آن درست نیست . اگر `Display` برای پذیرش یک `House` درگون می شد، نمی‌توانستید یک `Asset` را به آن بفرستید:
```Cs
Display (new Asset()); // کژکاری زمان گردآوری (Compile-time error)
public static void Display (House house) // یک Asset را نمی‌پذیرد
{
    System.Console.WriteLine (house.Mortgage);
}
```

### نوع‌ریزی (Casting) و تبدیل‌های ارجاعی (Reference Conversions)
یک ارجاع شیء می‌تواند:
- به گونه‌ی ضمنی **بالا-نوع‌ریزی (implicitly upcast)** به یک ارجاع کلاس پایه شود.

- به گونه‌ی آشکار **پایین-نوع‌ریزی (explicitly downcast)** به یک ارجاع زیرکلاس شود.

بالا-نوع‌ریزی و پایین-نوع‌ریزی بین گونه‌های ارجاعی سازگار (compatible reference types)، تبدیل‌های ارجاعی را انجام می‌دهند: یک ارجاع نو (به گونه‌ی منطقی) ساخته می‌شود که به همان شیء اشاره می‌کند. یک بالا-نوع‌ریزی همیشه موفق است؛ یک پایین-نوع‌ریزی تنها در صورتی موفق است که شیء به گونه‌ای مناسب گونه‌بندی شده باشد.

#### بالا-نوع‌ریزی (Upcasting)
یک عملیات بالا-نوع‌ریزی ، یک ارجاع کلاس پایه را از یک ارجاع زیرکلاس می سازد : 
```Cs
Stock msft = new Stock();
Asset a = msft; // بالا-نوع‌ریزی
```

پس از بالا-نوع‌ریزی ، متغیر `a` همچنان به همان شیء `Stock` که متغیر `msft` اشاره میکند،
خود شیء مورد ارجاع، دگرگون یا تبدیل نمی شود : 
```Cs
Console.WriteLine (a == msft); // True
```

گرچه `a` و `msft` به شیء همسان اشاره می کنند ، `a` دیدگاه محدودکننده‌تری بر روی آن شیء دارد : 
```Cs
Console.WriteLine (a.Name); // OK
Console.WriteLine (a.SharesOwned); // کژکاری زمان گردآوری
//کژکاری(Exception)
```
خط پایانی یک خطا زمان گردآوری پدید می‌آورد ، چرا که متغیر `a` از گونه‌ی `Asset` است گرچه به شیئی از گونه‌ی `Stock` اشاره می کند .
برای دسترسی به فیلد `SharesOwend` آن ، باید `Asset` را به یک `Stock` پایین-نوع‌ریزی کنید.

#### پایین-نوع‌ریزی (Downcasting)
یک عملیات پایین-نوع‌ریزی، یک ارجاع زیرکلاس را از یک ارجاع کلاس پایه می‌سازد:

```Cs
Stock msft = new Stock();
Asset a = msft; // بالا-نوع‌ریزی
Stock s = (Stock)a; // پایین-نوع‌ریزی
```csharp
Console.WriteLine (s.SharesOwned); // <بدون خطا>
Console.WriteLine (s == a); // True
Console.WriteLine (s == msft); // True
```
همانند یک بالا-نوع‌ریزی، تنها ارجاع‌ها اثر می‌پذیرند — نه شیء زیربنایی. یک پایین-نوع‌ریزی نیاز به یک نوع‌ریزی آشکار دارد،
چرا که به گونه‌ی بالقوه می‌تواند در زمان اجرا (runtime) شکست بخورد:

```Cs
House h = new House();
Asset a = h; // بالا-نوع‌ریزی همیشه موفق است
Stock s = (Stock)a; // پایین-نوع‌ریزی شکست می‌خورد: a یک Stock نیست
```

> اگر یک پایین-نوع‌ریزی شکست بخورد، یک InvalidCastException (کژکاری نوع‌ریزی نادرست) پرتاب می‌شود. این یک نمونه از بررسی**گونه در زمان اجرا (runtime type checking)** است.

### عملگر as
عملگر `as` یک پایین-نوع‌ریزی را انجام می‌دهد که اگر پایین-نوع‌ریزی شکست بخورد، به `null` ارزیابی می‌شود (به جای پرتاب یک خطا):

```Cs
Asset a = new Asset();
Stock s = a as Stock; // s برابر با null است؛ کژکاری پرتاب نمی‌شود
```

این کار زمانی سودمند است که شما میخواهید پس از آن بررسی کنید که آیا نتیجه `null` است یا نه:
```Cs
if (s != null) Console.WriteLine (s.SharesOwned);
```
بدون چنین آزمایشی ، یک نوع ریزی سودمندتر است ،
چرا که اگر شکست بخورد ، یک خطا گویاتر پرتاب می شود.
می توانیم با مقایسه‌ی دو خط کد زیر این را نشان دهیم : 
```Cs
long shares = ((Stock)a).SharesOwned; // رویکرد #1
long shares = (a as Stock).SharesOwned; // رویکرد #2
```

اگر `a` یک `Stock` نباشد ، خط نخست یک `InvalidCastException`(یک خطا از نوع‌ریزی نادرست) پرتاب می کند که شرح دقیقی از آنچه اشتباه رخ داده است، می دهد .
خط دوم یک `NullReferenceException ` (خطا برای ارجاع تهی (`null`)) پرتاب میکند 
که دوپهلو(ambiguous) است . آیا `a` یک `Stock` نبود، یا `a` برابر با `null` بود؟

راه دیگر برای نگاه کردن به آن این است که با عملگر نوع‌ریزی ، شما به گردآورنده می گویید : 
*من از گونه‌ی یک ارزش مطمئن هستم; اگر اشتباه کنم، در کد من یک نادرستی(bug) وجود دارد، پس یک خطا پرتاب کن*
درحالی که به عملگر `as` شما از گونه‌ی آن ناممئن هستید و می خواهید بر پایه‌ی نتیجه در زمان اجرا ، شاخه بندی کنید.

عملگر `as` نمی‌تواند تبدیل‌های سفارشی (custom conversions) را انجام دهد و نمی‌تواند تبدیل‌های عددی (numeric conversions) را انجام دهد:

```Cs
long x = 3 as long; // خطا زمان گردآوری
```

- عملگرهای `as` و نوع‌ریزی نیز بالا-نوع‌ریزی را انجام می‌دهند، گرچه این کار خیلی سودمند نیست، چرا که یک تبدیل ضمنی کار را انجام خواهد داد.

### عملگر is
عملگر `is` بررسی می‌کند که آیا یک متغیر با یک الگو (pattern) همسان است یا نه. سی‌شارپ از چندین گونه الگو پشتیبانی می‌کند که مهم‌ترین آن‌ها الگوی گونه (type pattern) است، جایی که یک نام گونه پس از کلیدواژه‌ی `is` می‌آید.

در این زمینه، عملگر `is` بررسی می‌کند که آیا یک تبدیل ارجاعی موفق خواهد بود — به سخن دیگر، آیا یک شیء از یک کلاس مشخص مشتق شده است (یا یک میانجی را پیاده‌سازی می‌کند). این عملگر اغلب برای آزمایش پیش از پایین-نوع‌ریزی به کار می‌رود:

```Cs
if (a is Stock)
{
Console.WriteLine (((Stock)a).SharesOwned);
}
```
عملگر is همچنین اگر یک تبدیل بازگشایی (unboxing conversion) موفق باشد، به `true` ارزیابی می‌شود. با این همه، تبدیل‌های سفارشی یا عددی را در نظر نمی‌گیرد.

> عملگر `is` با بسیاری از الگوهای دیگر که در نسخه‌های اخیر سی‌شارپ پدیدار شده‌اند، کار می‌کند.

### شناسایی یک متغیر الگو (Introducing a pattern variable)
شما می‌توانید در هنگام بهره‌گیری از عملگر `is`، یک متغیر الگو (pattern variable) را شناسایی کنید:

```Cs
if (a is Stock s)
    Console.WriteLine (s.SharesOwned);
```
این نمونه‌ی زیر هم ارز است : 
```Cs
Stock s;
if (a is Stock)
{
    s = (Stock) a;
    Console.WriteLine (s.SharesOwned);
}

```

متغیری که شما شناسایی می‌کنید، برای «مصرف بی‌درنگ» در دسترس است، بنابراین نمونه‌ی زیر درست است:
```Cs
if (a is Stock s && s.SharesOwned > 100000)
    Console.WriteLine ("Wealthy");
```

و در خارج از بیان `is` در دامنه (scope) باقی می‌ماند، که به این پروانه می‌دهد:
```Cs
if (a is Stock s && s.SharesOwned > 100000)
    Console.WriteLine ("Wealthy");
else
    s = new Stock(); // s در دامنه است
Console.WriteLine (s.SharesOwned); // همچنان در دامنه است
```

### اعضای تابع مجازی (Virtual Function Members)
یک تابع که به عنوان `virtual` نشان‌گذاری شده باشد، می‌تواند از سوی زیرکلاس‌هایی که می‌خواهند یک پیاده‌سازی (implementation) ویژه‌شده (specialized) را فراهم کنند، بازنویسی (override) شود. متدها، ویژگی‌ها (properties)، ایندکسرها (indexers)، و رویدادها (events) همگی می‌توانند مجازی (virtual) اعلام شوند:
```Cs
public class Asset
{
    public string Name;
    public virtual decimal Liability => 0; // ویژگی بیان-پیکر (Expression-bodied property)
}
```
> ( `Liability => 0` یک میان‌بر برای `{ get { return 0; } }` است. )

یک زیرکلاس، یک متد مجازی را با به کار بردن پالایشگر `override` بازنویسی می‌کند:
```Cs
public class Stock : Asset
{
    public long SharesOwned;
}

public class House : Asset
{
    public decimal Mortgage;
    public override decimal Liability => Mortgage;
}
```
به گونه‌ی پیش‌فرض، `Liability` (مسئولیت) یک `Asset` برابر با `0` است. یک `Stock` نیازی به ویژه‌سازی این رفتار ندارد. با این همه، `House` ویژگی `Liability` را برای بازگرداندن ارزش `Mortgage` ویژه‌سازی می‌کند:
```Cs
House mansion = new House { Name="McMansion", Mortgage=250000 };
Asset a = mansion;
Console.WriteLine (mansion.Liability); // 250000
Console.WriteLine (a.Liability); // 250000
```

امضاها (signatures)، گونه‌های بازگشتی (return types)، و دسترسی‌پذیری متدهای مجازی و بازنویسی‌شده باید همسان باشند. یک متد بازنویسی‌شده می‌تواند پیاده‌سازی کلاس پایه‌ی خود را از راه کلیدواژه‌ی `base` فراخوانی کند.

> فراخوانی متدهای مجازی از یک سازنده به گونه‌ی بالقوه پرخطر است، زیرا نویسندگان زیرکلاس‌ها 
> زمانی که متد را بازنویسی می‌کنند، به احتمال زیاد نمی‌دانند که با یک شیء نیمه‌آغازگری‌شده 
> (partially initialized) کار می‌کنند. به سخن دیگر، متد بازنویسی‌کننده ممکن است به متدها یا 
> ویژگی‌هایی دسترسی پیدا کند که به فیلدهایی وابسته هستند که هنوز از سوی سازنده آغازگری نشده‌اند.

**پی نوشت مترجم :**
> درک بهتر میتونید به این کد ها نگاه کنید :
> ```Cs
> // کلاس پایه‌ Enemy
> public class Enemy
> {
>    public string Name { get; set; }
>
>    // متد Attack را به صورت مجازی تعریف می‌کنیم
>    public virtual void Attack()
>    {
>        Console.WriteLine($"{Name} is attacking with a generic method.");
>    }
> }
>
>// زیرکلاس SwordEnemy
>public class SwordEnemy : Enemy
>{
>    // این زیرکلاس، متد Attack را بازنویسی می‌کند
>    public override void Attack()
>    {
>        Console.WriteLine($"{Name} is swinging a sword!");
>    }
>}
>
>// زیرکلاس MageEnemy
>public class MageEnemy : Enemy
>{
>    // این زیرکلاس نیز متد Attack را بازنویسی می‌کند
>    public override void Attack()
>    {
>        Console.WriteLine($"{Name} is casting a fireball spell!");
>    }
>}
> ```
> و استفاده : 
>```Cs
> Enemy[] enemies = new Enemy[3];
> enemies[0] = new Enemy { Name = "Goblin" };
>enemies[1] = new SwordEnemy { Name = "Knight" };
>enemies[2] = new MageEnemy { Name = "Sorcerer" };
>
>foreach (Enemy enemy in enemies)
>{
>    enemy.Attack(); // اینجا چندریختی رخ می‌دهد.
>}
>```
> خروجی : 
> ```
>Goblin is attacking with a generic method.
>Knight is swinging a sword!
>Sorcerer is casting a fireball spell!
>```


### گونه‌های بازگشتی هم‌ورد (Covariant return types)
از سی شارپ 9 شما میتوانید یک متد (یا `get accessor` ویژگی) را بازنویسی کنید،
به گونه‌ای که یک گونه‌ی مشتق شده‌تر(زیرکلاس) را بازگرداند. برای نمونه : 
```Cs
public class Asset
{
    public string Name;
    public virtual Asset Clone() => new Asset { Name = Name };
}

public class House : Asset
{
    public decimal Mortgage;
    public override House Clone() => new House
    { Name = Name, Mortgage = Mortgage };
}
```
این کار پروانه‌داده‌شده است، زیرا قراردادی که `Clone` باید یک `Asset` را بازگرداند، نمی‌شکند: این متد یک `House` را بازمی‌گرداند، که یک `Asset` (و بیشتر) است.

پیش از سی‌شارپ 9، شما ناچار بودید متدها را با گونه‌ی بازگشتی همسان بازنویسی کنید:
```Cs
public override Asset Clone() => new House { ... }
```

این هم کار را انجام می‌دهد، چرا که متد `Clone` بازنویسی‌شده به جای یک `Asset،` یک `House` را 
نمونه‌سازی می‌کند. با این همه، برای رفتار با شیء بازگشتی به عنوان یک `House،` باید یک 
پایین-نوع‌ریزی (downcast) را انجام دهید:

```Cs
House mansion1 = new House { Name="McMansion", Mortgage=250000 };
House mansion2 = (House) mansion1.Clone();
```

### کلاس‌های انتزاعی و اعضای انتزاعی (Abstract Classes and Abstract Members)
یک کلاسی که به عنوان `abstract` اعلام شده باشد، هرگز نمی‌تواند نمونه‌سازی شود. در عوض، تنها زیرکلاس‌های بتنی (concrete subclasses) آن می‌توانند نمونه‌سازی شوند.

کلاس‌های انتزاعی می‌توانند اعضای انتزاعی را شناسایی کنند. اعضای انتزاعی مانند اعضای مجازی 
هستند، با این تفاوت که یک پیاده‌سازی پیش‌فرض را فراهم نمی‌کنند. آن پیاده‌سازی باید از سوی 
زیرکلاس فراهم شود، مگر این که خود زیرکلاس نیز به عنوان `abstract` اعلام شده باشد:
```Cs
public abstract class Asset
{
    // به پیاده‌سازی تهی بنگرید
    public abstract decimal NetValue { get; }
}

public class Stock : Asset
{
    public long SharesOwned;
    public decimal CurrentPrice;

    // مانند یک متد مجازی بازنویسی کنید.
    public override decimal NetValue => CurrentPrice * SharesOwned;
}
```

### پنهان‌سازی اعضای ارث‌برده‌شده (Hiding Inherited Members)
یک کلاس پایه و یک زیرکلاس می‌توانند اعضای همسان را شناسایی کنند. برای نمونه:

```Cs
public class A { public int Counter = 1; }
public class B : A { public int Counter = 2; }

```
گفته می‌شود که فیلد `Counter` در کلاس `B`، فیلد `Counter` در کلاس `A` را پنهان می‌کند. 
معمولاً، این کار به گونه‌ی تصادفی رخ می‌دهد، هنگامی که یک عضو به گونه‌ی اصلی افزوده می‌شود 
پس از آن که یک عضو همسان به گونه‌ی فرعی افزوده شده بود. به همین دلیل، گردآورنده یک هشدار 
پدید می‌آورد و سپس ابهام را به گونه‌ی زیر حل می‌کند:

- ارجاع‌ها به A (در زمان گردآوری) به A.Counter پیوند می‌یابند.

- ارجاع‌ها به B (در زمان گردآوری) به B.Counter پیوند می‌یابند.

گاهی اوقات، شما می‌خواهید عمداً یک عضو را پنهان کنید، که در این صورت می‌توانید پالایشگر 
`new` را به عضو در زیرکلاس به کار ببرید. پالایشگر `new` کاری جز فرونشاندن هشدار گردآورنده که 
در غیر این صورت پدید می‌آمد، انجام نمی‌دهد:
```Cs
public class A { public int Counter = 1; }
public class B : A { public new int Counter = 2; }
```

پالایشگر `new` قصد شما را به گردآورنده — و به دیگر برنامه‌نویسان — می‌رساند که عضو کپی‌شده 
یک اشتباه نیست.

> سی‌شارپ کلیدواژه‌ی `new` را به گونه‌ای سنگین بارگذاری می‌کند که در زمینه‌های گوناگون، معانی 
> مستقل دارد. به گونه‌ی ویژه، عملگر `new` از پالایشگر عضو `new` جدا است.


#### new در برابر override
سلسله‌مراتب کلاس زیر را در نظر بگیرید:
```Cs
public class BaseClass
{
    public virtual void Foo() { Console.WriteLine ("BaseClass.Foo"); }
}

public class Overrider : BaseClass
{
    public override void Foo() { Console.WriteLine ("Overrider.Foo"); }
}

public class Hider : BaseClass
{
    public new void Foo() { Console.WriteLine ("Hider.Foo"); }
}
```

اختلاف در رفتار بین `Overrider` و `Hider` در کد زیر شنان داده شده است : 
```Cs
Overrider over = new Overrider();
BaseClass b1 = over;
over.Foo(); // Overrider.Foo
b1.Foo(); // Overrider.Foo

Hider h = new Hider();
BaseClass b2 = h;
h.Foo(); // Hider.Foo
b2.Foo(); // BaseClass.Foo
```

### مهر و موم کردن توابع و کلاس‌ها (Sealing Functions and Classes)

یک عضو تابع بازنویسی‌شده می‌تواند پیاده‌سازی خود را با کلیدواژه‌ی `sealed` مهر و موم کند تا 
از بازنویسی آن از سوی زیرکلاس‌های بعدی پیشگیری کند. در نمونه‌ی پیشین ما از عضو تابع مجازی، 
می‌توانستیم پیاده‌سازی `Liability` از `House` را مهر و موم کنیم و بدین گونه از بازنویسی 
`Liability` از سوی کلاسی که از `House` مشتق می‌شود، پیشگیری کنیم:


```Cs
public sealed override decimal Liability { get { return Mortgage; } }
```

شما همچنین می‌توانید پالایشگر `sealed` را به خود کلاس به کار ببرید تا از زیرکلاس‌سازی 
پیشگیری کنید. مهر و موم کردن یک کلاس رایج‌تر از مهر و موم کردن یک عضو تابع است.

گرچه می‌توانید یک عضو تابع را در برابر بازنویسی مهر و موم کنید، نمی‌توانید یک عضو را در 
برابر پنهان شدن مهر و موم کنید.


### کلیدواژه‌ی base

کلیدواژه‌ی `base` مانند کلیدواژه‌ی `this` است. دو هدف اساسی دارد:

- دسترسی به یک عضو تابع بازنویسی‌شده از زیرکلاس

- فراخوانی یک سازنده‌ی کلاس پایه

در این نمونه، `House` از کلیدواژه‌ی `base` برای دسترسی به پیاده‌سازی `Liability` از `Asset` 
بهره می‌برد:

```Cs
public class House : Asset
{
    // ...
    public override decimal Liability => base.Liability + Mortgage;
}
```

با کلیدواژه‌ی `base،` ما به ویژگی `Liability` از `Asset` به گونه‌ی غیرمجازی دسترسی پیدا 
می‌کنیم. این بدان معناست که ما همیشه به نسخه‌ی `Asset` از این ویژگی دسترسی پیدا خواهیم کرد — 
بی‌توجه به گونه‌ی واقعی نمونه در زمان اجرا.


همین رویکرد اگر `Liability` پنهان (hidden) شده باشد تا این که بازنویسی شده باشد نیز کار 
می‌کند. (شما همچنین می‌توانید با نوع‌ریزی به کلاس پایه پیش از فراخوانی تابع، به اعضای پنهان 
دسترسی پیدا کنید.)

### سازنده‌ها و ارث‌بری (Constructors and Inheritance)

یک زیرکلاس باید سازنده‌های خود را شناسایی کند.
سازنده های کلاس پایه برای کلاس مشتق‌شده دردسترس هستند.
اما هرگز به گونه‌ی خودکار ارث برده نمی شوند.
برای نمونه ، اگر `Baseclass` و `Subclass` را به گونه‌ی زیر شناسایی کنیم : 
```Cs
public class Baseclass
{
    public int X;
    public Baseclass () { }
    public Baseclass (int x) => X = x;
}

public class Subclass : Baseclass { }
```
نمونه‌ی زیر نادرست است : 
```Cs
Subclass s = new Subclass (123);
``` 

از این رو `Subclass` باید هر سازنده ای را که میخواهد نمایان کند <دوباره شناسایی> کند.
با این همه ، در این فرآیند می تواند هر یک از سازنده‌های کلاس پایه را از راه کلیدواژه‌ی `base` فراخوانی کند:
```Cs
public class Subclass : Baseclass
{
    public Subclass (int x) : base (x) { }
}
```
کلیدواژه‌ی `base` به گونه‌ای مانند کلیدواژه‌ی `this` کار می‌کند، با این تفاوت که یک سازنده را در کلاس پایه فراخوانی می‌کند.

سازنده های کلاس پایه همیشه نخست اجرا می شوند،
این کار پایداری میدهد که آغازگری پایه پیش از آغازگری ویژه شده ها رخ دهد.

### فراخوانی ضمنی سازنده‌ی کلاس پایه‌ی بدون پارامتر

اگر یک سازنده در یک زیرکلاس کلیدواژه `base` را نادیده بگیرد،
سازنده‌ی بدون پارامتر گونه‌ی پایه به گونه‌ی ضمنی فراخوانی میشود:
```Cs
public class Baseclass
{
    public int X;
    public Baseclass() { X = 1; }
}

public class Subclass : Baseclass
{
    public Subclass() { Console.WriteLine (X); } // 1
}
```

اگر کلاس پایه یک سازنده‌ی بدون پارامتر قابل دسترسی نداشته باشد، زیرکلاس‌ها ناچار به بهره‌گیری از کلیدواژه‌ی `base` در سازنده‌های خود می‌شوند. این بدان معناست که یک کلاس پایه با (تنها) یک سازنده‌ی چندپارامتره، زیرکلاس‌ها را با وظیفه‌ی فراخوانی آن سنگین می‌کند:
```Cs
class Baseclass
{
    public Baseclass (int x, int y, int z, string s, DateTime d) { ... }
}

public class Subclass : Baseclass
{
    public Subclass (int x, int y, int z, string s, DateTime d)
    : base (x, y, z, s, d) { ... }
}

```
### اعضای لازم (Required members) (سی‌شارپ 11)

نیاز زیرکلاس ها به فرخوانی یک سازنده در کلاس پایه می تواند در سلسله مراتب کلاس های بزرگ اگر 
سازنده های زیادی با پارامتر های بسیاز وجود داشته باشند ، سنگین شود، گاهی اوقات بهترین راه حل 
این است که به گونه‌ی کامل از سازنده ها دوری کنیم و تنها به آغازگرهای شیء (object 
initializers) تکیه کنیم تا فیلدها یا ویژگی ها را در هنگام ساختن تنظیم کنیم.
برای یاری به این کار، میتوانید یک فیلد یا ویژگی را به عنوان `required` (از سی شارپ 11) 
نشانگذاری کنید : 
```Cs
public class Asset
{
    public required string Name;
}
```

یک عضو لازم باید در هنگام ساختن از راه یک آغازگر شیء مقداردهی شود : 
```Cs
Asset a1 = new Asset { Name="House" }; // OK
Asset a2 = new Asset(); // خطا: گردآوری نمی‌شود!
```
اگر بخواهید یک سازنده نیز بنویسید ، می توانید سرآیند `[SetsRequiredMembers]` را به کار ببرید 
تا محدودیت عضو لازم را برای آن سازنده نادیده بگیرید:
```Cs
public class Asset
{
    public required string Name;
    public Asset() { }

    [System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
    public Asset (string n) => Name = n;
}
```
مصرف کنندگان اکنون می توانند از آسانی آن سازنده بدون هیچگونه بده‌بستان (trade-off) بهره ببرید : 
```Cs
Asset a1 = new Asset { Name = "House" }; // OK
Asset a2 = new Asset ("House"); // OK
Asset a3 = new Asset(); // کژکاری!
```
بنگرید که ما یک سازنده‌ی بدون پارامتر نیز شناسایی کرده ایم (برای بهره‌گیری با آغازگر شیء).
بودن آن همچنین پایداری می دهد که زیرکلاس‌ها زیر هیچ بارِ دوباره پدید آوردن هیچ سازنده‌ای نباشند .
در نمونه‌ی زیر ، کلاس `House` گزینش میکند که یک سازنده‌ی آسانی را پیاده سازی نکند : 
```Cs
public class House : Asset { } // بدون سازنده، بی‌درنگ!
House h1 = new House { Name = "House" }; // OK
House h2 = new House(); // کژکاری!
```


### ترتیب آغازگری سازنده و فیلد
هنگامی که یک شیء نمونه سازی می شود، آغازگری به ترتیب زیر رخ می دهد : 

+ از زیرکلاس به کلاس پایه : 
> الف. فیلدها آغازگری میشوند.
> ب. آرگومان های فراخوانی سازنده‌ی کلاس پایه ارزیابی میشوند.
+ از کلاس پایه به زیرکلاس : 
> الف. پیکر(body) سازنده اجرا می شود.

برای نمونه :
```Cs
public class B
{
    int x = 1; // سوم اجرا می‌شود
    public B (int x)
    {
    // ... // چهارم اجرا می‌شود
    }
}

public class D : B
{
    int y = 1; // نخست اجرا می‌شود
    public D (int x)
    : base (x + 1) // دوم اجرا می‌شود
    {
    // ... // پنجم اجرا می‌شود
    }
}
```

### ارث‌بری با سازنده‌های اصلی (Inheritance with primary constructors)
کلاس هایی با سازنده های اصلی می توانند با ساختار نوشتاری زیر زیرکلاس‌سازی کنند:

```Cs
public class Baseclass (int x) { ... }
public class Subclass (int x, int y) : Baseclass (x) { ... }
```
فراخوانی `Baseclass(x)` با فرخوانی `base(x)` در نمونه‌ی زیر هم‌ارز است: 
```Cs
public class Subclass : Baseclass
{
    public Subclass (int x, int y) : base (x) { ... }
}
```

### بارگذاری سنگین و حل بارگذاری (Overloading and Resolution)
ارث بری یک اثر جالب بر بارگذاری سنگین متدها دارد .
دو بارگذاری سنگین زیر را در نظر بگیرید : 
```Cs
static void Foo (Asset a) { }
static void Foo (House h) { }
```
هنگامی که یک بارگذاری سنگین فرخوانی می شود ، گونه‌ی ویژه‌ترین (most specific) ارجحیت دارد : 
```Cs
House h = new House (...);
Foo(h); // Foo(House) را فراخوانی می‌کند
```
بارگذاری سنگین ویژه‌ای که باید فرخوانی شود، به گونه‌ی ایستا (در زمان کامپایل(گردآوری)) تا به جای زمان اجرا تعیین می شود.
کد زیر `Foo(Asset)` را فرخوانی می کند،
گرچه گونه‌ی زمان اجرای `House` ، `a` است : 
```Cs
Asset a = new House (...);
Foo(a); // Foo(Asset) را فراخوانی می‌کند
```

اگر `Asset` را به `dynamic` نوع‌ریزی کنید، تصمیم در باره‌ی این که کدام بارگذاری سنگین فرخوانی شود تا زمان اجرا به دیرکرد می افتد و سپس بر پایه‌ی گونه‌ی واقعی شیء است : 
```Cs
Asset a = new House (...);
Foo ((dynamic)a); // Foo(House) را فراخوانی می‌کند
```

> **پی نوشت مترجم**
> ببنید شاید مطلب بالا کمی گیج کننده باشد  بیایم ساده سازی کنیم :
> ```Cs
>House h = new House();
>Foo(h);
>```
> این کد را در نظر بگیرید 
> در اینجا، گردآورنده می‌بیند که گونهٔ h از نوع `House` است. چون یک متد `Foo` دقیقاً با این گونه وجود دارد (`Foo(House h)`)، گردآورنده آن را برمی‌گزیند. این متد، ویژه‌ترین متد ممکن است.
> اما در این نمونه : 
> ```Cs
>Asset a = new House();
>Foo(a);
>```
>در این مورد، با اینکه در زمان اجرا، شیء a در حقیقت یک `House` است، اما گردآورنده فقط به گونهٔ ایستا یا همان `Asset` نگاه می‌کند. گردآورنده می‌بیند که یک متد `Foo` با آرگومان `Asset` وجود دارد. چون هیچ متد دیگری با گونهٔ ویژه‌تر `Asset` وجود ندارد، `Foo(Asset a)` را برمی‌گزیند.
> **پویاسازی (Dynamic) برای حل بارگذاری در زمان اجرا**
>راه حل این مشکل، همانطور که در متن بالا دیدید، بهره‌گیری از کلیدواژهٔ `dynamic` است. وقتی یک متغیر را از گونهٔ `dynamic` می‌سازید، به گردآورنده می‌گویید که تصمیم‌گیری دربارهٔ گونهٔ آن متغیر را به زمان اجرا بیندازد.
> در این هنگام :
> - گردآورنده می‌بیند که شما می‌خواهید متد `Foo` را با یک آرگومان `dynamic` فراخوانی کنید.
> - گردآورنده تصمیم‌گیری را به **زمان اجرا (Runtime)** موکول می‌کند.
> - در زمان اجرا، سامانه‌ی زبان (CLR) بررسی می‌کند که گونهٔ واقعی شیء درون `a` چیست.
> - گونهٔ واقعی `a` یک `House` است.
> - سامانه به دنبال ویژه‌ترین متد `Foo` با گونهٔ `House` می‌گردد و `Foo(House h)` را پیدا و فراخوانی می‌کند.



### گونه‌ی `object` (System.Object)

`object` (`System.Object`) کلاس پایه‌ی نهایی برای همه‌ی گونه‌ها است. هر گونه‌ای می‌تواند به `object` بالا-نوع‌ریزی شود.

برای روشن ساختن این که چرا این سودمند است، یک پشته(stack) با کارکرد همگانی را در نظربگیرید .
یک پشته یک داده ساختار است که بر پایه‌ی اصل LIFO — «آخرین درون، نخستین بیرون» — است. یک پشته 
دو کارکرد دارد: راندن (push) یک شیء به درون پشته و بیرون کشیدن (pop) یک شیء از پشته. این هم 
یک پیاده‌سازی ساده که می‌تواند تا 10 شیء را در خود جای دهد:

```Cs
public class Stack
{
    int position;
    object[] data = new object[10];
    public void Push (object obj) { data[position++] = obj; }
    public object Pop() { return data[--position]; }
}

```

از آنجا که `Stack` با گونه‌ی `object` کار میکند،  میتوانیم نمونه هایی از هر گونه‌ای را به 
درون `Stack` برانیم و از آن بیرون بکشیم:
```Cs
Stack stack = new Stack();
stack.Push ("sausage");
string s = (string) stack.Pop(); // پایین-نوع‌ریزی، از این رو نوع‌ریزی آشکار نیاز است
Console.WriteLine (s); // sausage
object` یک گونه‌ی ارجاعی (reference type)
```
 است، به این دلیل که یک کلاس است. با این همه، گونه‌های ارزشی (value types) مانند `int` نیز می‌توانند به و از `object` نوع‌ریزی شوند و بدین گونه به پشته‌ی ما افزوده شوند. این ویژگی سی‌شارپ **یگانگی گونه (type unification)** خوانده می‌شود و در اینجا نشان داده شده است:

```Cs
stack.Push (3);
int three = (int) stack.Pop();
```

هنگامی که شما بین یک گونه‌ی ارزشی و `object` نوع‌ریزی می‌کنید، CLR باید یک کار ویژه را برای 
پل زدن بر اختلاف در معناشناسی بین گونه‌های ارزشی و ارجاعی انجام دهد. این فرآیند جعبه‌گذاری 
(boxing) و جعبه‌گشایی (unboxing) خوانده می‌شود.

> در بخش «عمومی‌ها (Generics)» در رویه‌ی 159، ما چگونگی بهبود کلاس `Stack` را برای رفتار بهتر با پشته‌هایی با اندام‌های هم‌گونه شناسایی می‌کنیم.

### جعبه‌گذاری و جعبه‌گشایی (Boxing and Unboxing)
Boxing (جعبه‌گذاری) کنش تبدیل یک نمونه از **value type** (گونهٔ ارزشی) به یک نمونه از `reference` 
`type` (گونهٔ ارجاعی) است. این `reference type` می‌تواند هم کلاس `object` باشد و هم یک `interface` 
(میانجی) باشد (که در آینده در این بخش به آن می‌پردازیم). در این نمونه، ما یک int را درون یک 
`object` boxing می‌کنیم:
```Cs
int x = 9;
object obj = x; // boxing یک int
```
**Unboxing** (جعبه‌گشایی) با تبدیل شیء به `value type` (گونهٔ ارزشی) اصلی، عملیات را برعکس می‌کند:

```Cs
int y = (int)obj; // unboxing یک int
```

**Unboxing** نیاز به یک `explicit cast` (نوع‌ریزی آشکار) دارد. زمان اجرا بررسی می‌کند که `value` 
`type` (گونهٔ ارزشی) بیان‌شده با گونه‌ی واقعی شیء همسان باشد و اگر بررسی شکست بخورد، یک 
`InvalidCastException` پرتاب می‌کند. برای نمونه، نمونه‌ی زیر یک کژکاری (استثنا) پرتاب می‌کند، چرا 
که `long` با `int` به گونه‌ی دقیق همسان نیست:

```Cs
object obj = 9; // 9 از گونه‌ی int است
long x = (long) obj; // InvalidCastException
```
با این همه، نمونه‌ی زیر موفق است:
```Cs
object obj = 9;
long x = (int) obj;
```
همچنین نمونه‌ی زیر نیز موفق است:
```Cs
object obj = 3.5; // 3.5 از گونه‌ی double است
int x = (int) (double) obj; // x اکنون 3 است
```
در نمونه‌ی پایانی، (double) یک unboxing (جعبه‌گشایی) انجام می‌دهد و سپس (int) یک تبدیل عددی را انجام می‌دهد.

- تبدیل‌های boxing در فراهم کردن یک unified type system (سامانه‌ی گونه‌ی یگانه) حیاتی هستند. با این همه، این سامانه بی‌نقص نیست: در بخش «عمومی‌ها (Generics)» در رویه‌ی 159 خواهیم دید که variance (دگرگونی‌پذیری) با آرایه‌ها و عمومی‌ها تنها از تبدیل‌های reference (ارجاعی) پشتیبانی می‌کند و نه از تبدیل‌های boxing:
```Cs
object[] a1 = new string[3]; // درست
object[] a2 = new int[3]; // خطا
```

> 1. گونه‌ی ارجاعی می‌تواند همچنین `System.ValueType` یا `System.Enum` (فصل 6) باشد.


### معناشناسی کپی‌برداری در Boxing و Unboxing

**Boxing**، نمونه‌ی value type (گونه‌ی ارزشی) را به درون شیء نو کپی می‌کند و unboxing، محتویات شیء را دوباره به درون یک نمونه از value type (گونه‌ی ارزشی) کپی می‌کند. در نمونه‌ی زیر، دگرگون کردن ارزش i، کپی پیشین boxed آن را دگرگون نمی‌کند:

```Cs
int i = 3;
object boxed = i;
i = 5;
Console.WriteLine (boxed); // 3
```


### بررسی گونه ایستا و زمان اجرا (Static and Runtime Type Checking)
برنامه‌های سی‌شارپ هم به گونه‌ی ایستا (در زمان گردآوری) و هم در زمان اجرا (از سوی CLR) بررسی 
گونه می‌شوند.

بررسی گونه‌ی ایستا گردآورنده را توانا می‌سازد تا درستی برنامه‌ی شما را بدون اجرا کردن آن، 
وارسی کند. کد زیر شکست خواهد خورد، چرا که گردآورنده گونه‌بندی ایستا را پافشاری می‌کند:

```Cs
int x = "5";
```
بررسی گونه‌ی زمان اجرا از سوی CLR هنگامی انجام می‌شود که شما از راه یک تبدیل ارجاعی یا جعبه‌گشایی، پایین-نوع‌ریزی می‌کنید:

```Cs
object y = "5";
int z = (int) y; // کژکاری زمان اجرا، پایین-نوع‌ریزی شکست خورد
```

بررسی گونه‌ی زمان اجرا شدنی است، زیرا هر شیء بر روی هیپ (`heap`) به گونه‌ی درونی یک نشانه‌ی 
گونه‌ی کوچک را نگه می‌دارد. شما می‌توانید این نشانه را با فراخوانی متد `GetType` از `object` 
به دست آورید.


### متد `GetType` و عملگر `typeof`
همه‌ی گونه‌ها در سی‌شارپ در زمان اجرا با یک نمونه از `System.Type` نشان داده می‌شوند. دو راه 
اصلی برای به دست آوردن یک شیء `System.Type` وجود دارد:

- فراخوانی `GetType` بر روی نمونه

- به کار بردن عملگر `typeof` بر روی یک نام گونه

`GetType` در زمان اجرا ارزیابی می‌شود؛ `typeof` به گونه‌ی ایستا در زمان گردآوری ارزیابی 
می‌شود (هنگامی که پارامترهای گونه‌ی عمومی دخیل هستند، از سوی گردآورنده‌ی JIT حل می‌شود).

`System.Type` ویژگی‌هایی برای چیزهایی مانند نام گونه، سرهم‌بندی (`assembly`)، گونه‌ی پایه و... دارد:
```Cs
Point p = new Point();
Console.WriteLine (p.GetType().Name); // Point
Console.WriteLine (typeof (Point).Name); // Point
Console.WriteLine (p.GetType() == typeof(Point)); // True
Console.WriteLine (p.X.GetType().Name); // Int32
Console.WriteLine (p.Y.GetType().FullName); // System.Int32

public class Point { public int X, Y; }
```

`System.Type` همچنین متدهایی دارد که به عنوان دروازه‌ای به الگوی بازتاب (reflection model) زمان اجرا عمل می‌کنند.

### متد `ToString`

متد `ToString` نمایش متنی پیش‌فرض یک نمونه‌ی گونه را بازمی‌گرداند. این متد از سوی همه‌ی گونه‌های توکار بازنویسی شده است. این هم یک نمونه از بهره‌گیری از متد `ToString` گونه‌ی `int`:

```Cs
int x = 1;
string s = x.ToString(); // s برابر با "1" است
```
شما می‌توانید متد `ToString` را بر روی گونه‌های سفارشی به گونه‌ی زیر بازنویسی کنید:

```Cs
Panda p = new Panda { Name = "Petey" };
Console.WriteLine (p); // Petey

public class Panda
{
    public string Name;
    public override string ToString() => Name;
}
```
اگر `ToString` را بازنویسی نکنید، متد نام گونه را بازمی‌گرداند.

> هنگامی که یک عضو بازنویسی‌شده‌ی `object` مانند `ToString` را به گونه‌ی مستقیم بر روی یک 
> گونه‌ی ارزشی فراخوانی می‌کنید، جعبه‌گذاری رخ نمی‌دهد. جعبه‌گذاری تنها در صورتی رخ می‌دهد 
> که شما نوع‌ریزی کنید:
> ```Cs
> int x = 1;
> string s1 = x.ToString(); // فراخوانی بر روی ارزش جعبه‌گذاری‌نشده
> object box = x;
> string s2 = box.ToString(); // فراخوانی بر روی ارزش جعبه‌گذاری‌شده
> ```

### فهرست اعضای `object`
این همه‌ی اعضای `object` است:
```Cs
public class Object
{
    public Object();
    public extern Type GetType();
    public virtual bool Equals (object obj);
    public static bool Equals (object objA, object objB);
    public static bool ReferenceEquals (object objA, object objB);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual void Finalize();
    protected extern object MemberwiseClone();
}
```

- ما روش‌های `Equals`، `ReferenceEquals` و `GetHashCode` را در بخش «همسنجی برابری» در برگهٔ ۳۴۴ می‌نگاریم.

### Structs
**struct** همانند یک **class** است، با این تفاوت‌های کلیدی:

- یک struct یک value type (گونهٔ ارزشی) است، در حالی که یک class یک reference type (گونهٔ ارجاعی) است.

- یک struct از ارث‌بری (inheritance) پشتیبانی نمی‌کند (جز اشتقاق ضمنی از `object`، یا به‌طور دقیق‌تر، `System.ValueType`).

یک `struct` می‌تواند تمام اعضایی را که یک `class` می‌تواند داشته باشد، داشته باشد، به‌جز یک 
`finalizer`. و چون نمی‌توان از آن زیرکلاس ساخت، اعضا نمی‌توانند به عنوان `virtual،` 
`abstract،` یا `protected` نشان‌گذاری شوند.

> پیش از `C# 10`، structها از تعریف اولیهٔ فیلدها و سازنده‌های بدون پارامتر منع شده بودند. با 
> اینکه این منع اکنون برداشته شده است—در درجهٔ نخست برای سودمندی `record struct`ها (نگاه کنید 
> به `«Records»` در رویهٔ ۲۲۷)—باید پیش از تعریف این ساختارها با دقت بیندیشید، چرا که '
> می‌توانند به رفتارهای گیج‌کننده‌ای بینجامند که در «معناشناسی ساختار `struct`» در رویهٔ ۱۴۲، 
> آن‌ها را توصیف خواهیم کرد.


یک `struct` هنگامی مناسب است که معناشناسی گونهٔ ارزشی مطلوب باشد. نمونه‌های خوب برای `struct،` 
گونه‌های عددی هستند، که در آن‌ها طبیعی‌تر است که انتساب، یک ارزش را کپی کند تا یک ارجاع را. 
از آنجا که یک `struct` یک گونهٔ ارزشی است، هر نمونه به نمونه‌سازی یک شیء بر روی `heap` نیاز 
ندارد؛ این به صرفه‌جویی مفیدی در هنگام ساخت نمونه‌های بسیاری از یک گونه می‌انجامد. برای 
نمونه، ساخت یک آرایه از عنصرهای گونهٔ ارزشی تنها به یک تخصیص `heap` نیاز دارد.
از آنجا که `struct` ها گونه‌های ارزشی هستند، یک نمونه نمی‌تواند `null` باشد. ارزش پیش‌فرض 
برای یک `struct` یک نمونهٔ تهی است، که تمام فیلدها تهی (برابر با ارزش‌های پیش‌فرض خود) هستند.


### معناشناسی ساختار Struct
پیش از `C# 11`، هر فیلد در یک `struct` می‌بایست به‌طور صریح در سازنده (یا در مقدار اولیهٔ فیلد) مقداری به آن اختصاص داده می‌شد. این محدودیت اکنون برداشته شده است.

### سازندهٔ پیش‌فرض
علاوه بر هر سازنده‌ای که شما تعریف می‌کنید، یک `struct` همواره یک سازندهٔ بدون پارامتر ضمنی 
دارد که یک صفرگذاری بیتی (`bitwise-zeroing`) برای فیلدهای خود انجام می‌دهد (آن‌ها را به 
ارزش‌های پیش‌فرضشان تنظیم می‌کند):

```CS
Point p = new Point(); // p.x و p.y برابر با 0 خواهند بود
struct Point { int x, y; }
```
حتی هنگامی که شما یک سازندهٔ بدون پارامتر از خودتان تعریف می‌کنید، سازندهٔ بدون پارامتر ضمنی همچنان وجود دارد و می‌توان از راه واژهٔ کلیدی `default` به آن دسترسی داشت:

```CS
Point p1 = new Point(); // p1.x و p1.y برابر با 1 خواهند بود
Point p2 = default; // p2.x و p2.y برابر با 0 خواهند بود

struct Point
{
int x = 1;
int y;
public Point() => y = 1;
}
```
در این نمونه، ما x را با یک مقدار اولیهٔ فیلد به ۱ مقداردهی کردیم و y را با سازندهٔ بدون 
پارامتر به ۱ مقداردهی کردیم. و با این همه، با واژهٔ کلیدی `default`، همچنان توانستیم یک 
`Point` بسازیم که از هر دو مقداردهی اولیه فراتر رفته است. به سازندهٔ پیش‌فرض به روش‌های 
دیگری نیز می‌توان دسترسی داشت، همان‌گونه که در نمونهٔ زیر نشان داده شده است:

```Cs
var points = new Point[10]; // هر Point در آرایه (0,0) خواهد بود
var test = new Test(); // test.p برابر با (0,0) خواهد بود

class Test { Point p; }
```

داشتن آنچه به دو سازندهٔ بدون پارامتر می‌انجامد می‌تواند سرچشمهٔ سردرگمی باشد، و شاید دلیلی خوب 
برای پرهیز از تعریف مقداردهی اولیهٔ فیلد و سازنده‌های بدون پارامتر صریح در `struct`ها باشد.
یک استراتژی خوب با `struct`ها این است که آن‌ها را به گونه‌ای طراحی کنید که ارزش پیش‌فرض آن‌ها یک 
حالت معتبر باشد، بدین گونه مقداردهی اولیه را اضافی می‌سازید. برای نمونه، به‌جای مقداردهی اولیهٔ 
یک خصوصیت به گونهٔ زیر:

```Cs
public string Protocol { get; set; } = "https";
```
این نمونه را در نظر بگیرید:
```Cs
struct WebOptions
{
string protocol;
public string Protocol { get => protocol ?? "https";
set => protocol = value; }
}
```

### Structها و توابع Read-Only
شما می‌توانید اصلاح‌گر `readonly` را به یک `struct` اعمال کنید تا بر روی همهٔ فیلدها `readonly` 
بودن را پافشاری کنید؛ این کار به بیان مقصود کمک می‌کند و همچنین به گردآورنده آزادی بهینه‌سازی 
بیشتری می‌دهد:

```Cs
readonly struct Point
{
public readonly int X, Y; // X و Y باید readonly باشند
}
اگر نیاز دارید که readonly بودن را در یک سطح ریزتر اعمال کنید، می‌توانید اصلاح‌گر readonly (از C# 8) را به توابع یک struct اعمال کنید. این کار اطمینان می‌دهد که اگر تابع بخواهد هر فیلدی را دگرگون کند، یک خطای زمان گردآوری ساخته می‌شود:

struct Point
{
public int X, Y;
public readonly void ResetX() => X = 0; // Error!
}
```

اگر یک تابع `readonly` یک تابع غیر `readonly` را فراخوانی کند، گردآورنده یک اخطار می‌سازد (و `struct` را به گونه‌ای دفاعی کپی می‌کند تا از امکان یک دگرگونی جلوگیری کند).

### Ref Structs
**Ref struct**ها در C# 7.2 به عنوان یک ویژگی فرعی در درجهٔ نخست برای سودمندی `struct`های 
`Span<T> `و `ReadOnlySpan<T>` که در فصل ۲۳ توصیف می‌کنیم (و `Utf8JsonReader` بسیار 
بهینه‌سازی‌شده‌ای که در فصل ۱۱ توصیف می‌کنیم) معرفی شدند. این structها به یک روش بهینه‌سازی 
بسیار ریز کمک می‌کنند که هدفش کاهش تخصیص حافظه است.



برخلاف گونه‌های ارجاعی، که نمونه‌هایشان همواره بر روی `heap` زندگی می‌کنند، گونه‌های ارزشی در 
جای خود (هر کجا که متغیر اعلام شده است) زندگی می‌کنند. اگر یک گونهٔ ارزشی به عنوان یک پارامتر یا 
متغیر محلی ظاهر شود، بر روی `stack` ساکن خواهد شد:
```Cs
void SomeMethod()
{
Point p; // p بر روی stack ساکن خواهد شد
}
struct Point { public int X, Y; }
```
اما اگر یک گونهٔ ارزشی به عنوان یک فیلد در یک `class` ظاهر شود، بر روی `heap` ساکن خواهد شد:
```Cs
class MyClass
{
Point p; // بر روی heap زندگی می‌کند، چرا که نمونه‌های MyClass بر روی heap زندگی می‌کنند
}
```

به همین ترتیب، آرایه‌های `struct`ها بر روی `heap` زندگی می‌کنند و جعبه‌گذاری یک `struct` آن را 
به `heap` می‌فرستد.

افزودن اصلاح‌گر ref به اعلام یک `struct` اطمینان می‌دهد که آن تنها می‌تواند بر روی `stack` ساکن 
شود. تلاش برای به کار بردن یک `ref` `struct` به گونه‌ای که بتواند بر روی `heap` ساکن شود، یک 
خطای زمان گردآوری می‌سازد:

```Cs
var points = new Point[100]; // Error: گردآوری نخواهد شد!

ref struct Point { public int X, Y; }
class MyClass { Point P; } // Error: گردآوری نخواهد شد!
```

`Ref struct`ها در اصل برای سودمندی `struct`های `Span<T>` و `ReadOnlySpan<T>` معرفی شدند. از آنجا 
که نمونه‌های `Span<T>` و `ReadOnlySpan<T>` تنها می‌توانند بر روی `stack` وجود داشته باشند، ممکن 
است که آن‌ها به‌گونه‌ای ایمن، حافظهٔ تخصیص‌یافته بر روی `stack` را دربرگیرند.

`Ref` `struct`ها نمی‌توانند در هیچ ویژگی C# که به‌طور مستقیم یا غیرمستقیم امکان وجود بر روی 
`heap` را معرفی می‌کند، شرکت کنند. این شامل شماری از ویژگی‌های پیشرفتهٔ C# است که در فصل ۴ توصیف 
می‌کنیم، یعنی `lambda expressions`، `iterators` و توابع ناهمگام (`asynchronous functions`) (زیرا 
در پشت صحنه، این ویژگی‌ها همگی کلاس‌های پنهانی با فیلدها می‌سازند). همچنین، ref structها 
نمی‌توانند در داخل `struct`های غیر `ref` ظاهر شوند و نمی‌توانند `interface`ها را پیاده‌سازی کنند 
(چرا که این کار می‌تواند به جعبه‌گذاری بینجامد).

### اصلاح‌کننده‌های دسترسی (Access Modifiers) 🔑

برای ارتقاء اصل کپسوله‌سازی (`encapsulation`)، یک نوع 
یا یک عضو از نوع می‌تواند با افزودن یک اصلاح‌کننده 
دسترسی (`access modifier`) به اعلان خود، دسترسی به 
آن‌ها را برای انواع و اسمبلی‌های دیگر محدود کند:

`public 🌐`
کاملاً قابل دسترسی. این سطح دسترسی پیش‌فرض برای اعضای یک enum یا interface است.

`internal 🏠`

فقط در داخل اسمبلیِ حاوی (containing assembly) یا اسمبلی‌های دوست (friend assemblies) قابل دسترسی است. این سطح دسترسی پیش‌فرض برای انواع غیر-تو در تو (non-nested types) است.

`private 🔒`
فقط در داخل نوعِ حاوی (containing type) قابل دسترسی است. این سطح دسترسی پیش‌فرض برای اعضای یک class یا struct است.

`protected 🛡️`
فقط در داخل نوعِ حاوی یا زیرکلاس‌ها (subclasses) قابل دسترسی است.

`protected internal 🤝`
اتحاد (union) سطح دسترسی protected و internal. یک عضو که protected internal است، از دو طریق قابل دسترسی است.

`private protected 🤫`
اشتراک (intersection) سطح دسترسی protected و internal. یک عضو که `private protected` است، فقط 
در داخل نوعِ حاوی یا از زیرکلاس‌هایی که در همان اسمبلی قرار دارند (بنابراین نسبت به 
protected یا internal به تنهایی کمتر قابل دسترسی است) قابل دسترسی است.

`file` (از سی‌شارپ 11) 📄
فقط از داخل همان فایل قابل دسترسی است. برای استفاده توسط source generators (به "متدهای partial گسترش‌یافته" در صفحه 125 مراجعه کنید) در نظر گرفته شده است. این اصلاح‌کننده فقط می‌تواند برای اعلان‌های نوع (type declarations) به کار رود.

**مثال‌ها 📝** : 
`Class2` از خارج از اسمبلی خود قابل دسترسی است؛ اما `Class1` نیست:
```Cs
class Class1 {} // Class1 is internal (default)
public class Class2 {}
```
`ClassB` فیلد `x` را برای سایر انواع در همان اسمبلی در دسترس قرار می‌دهد؛ `ClassA` این کار را نمی‌کند:
```cs
class ClassA { int x; } // x is private (default)
class ClassB { internal int x; }
```
توابع در داخل `Subclass` می‌توانند `Bar` را فراخوانی کنند اما `Foo` را نمی‌توانند:

```Cs
class BaseClass
{
    void Foo() {} // Foo is private (default)

    protected void Bar() {}
}

class Subclass : BaseClass
{
    void Test1() { Foo(); } // Error - cannot access Foo
    void Test2() { Bar(); } // OK
}
```

### Friend Assemblies
شما می‌توانید اعضای `internal` را با افزودن `attribute` اسمبلیِ `System.Runtime.
CompilerServices.InternalsVisibleTo` به اسمبلی‌های دوست دیگر در دسترس قرار دهید. برای این 
کار باید نام Friend Assemblies را به صورت زیر مشخص کنید:

```CS
[assembly: InternalsVisibleTo ("Friend")]
```
اگر Friend Assemblies یک strong name (به فصل 17 مراجعه کنید) داشته باشد، باید کلید عمومی 
160-بایتی کامل آن را مشخص کنید:

```Cs
[assembly: InternalsVisibleTo ("StrongFriend, PublicKey=0024f000048c...")]
```
شما می‌توانید کلید عمومی کامل را از یک اسمبلی دارای strong name با یک LINQ query (در فصل 8 
به تفصیل LINQ را توضیح می‌دهیم) استخراج کنید:

```Cs
string key = string.Join ("",
 Assembly.GetExecutingAssembly().GetName().GetPublicKey()
 .Select (b => b.ToString ("x2")));
```

نمونه همراه در LINQPad از شما می‌خواهد تا یک اسمبلی را browse کرده و سپس کلید عمومی کامل آن را در clipboard کپی می‌کند.

### محدودسازی دسترسی (Accessibility Capping) 🧢

یک نوع، دسترسی اعضای اعلان‌شده‌ی خود را محدود می‌کند. رایج‌ترین مثال از این محدودسازی، زمانی 
است که یک نوع `internal` با اعضای `public` دارید. برای مثال، به این کد توجه کنید:

```Cs
class C { public void Foo() {} }
```
دسترسی `internal` (پیش‌فرض) برای کلاس `C`، دسترسی `Foo` را محدود می‌کند و عملاً `Foo` را به 
`internal` تبدیل می‌کند. دلیل رایجی که `Foo` به صورت `public` مشخص می‌شود، این است که اگر در 
آینده `C` به `public` تغییر یابد، `Refactoring` آسان‌تر شود.

### محدودیت‌ها بر روی اصلاح‌کننده‌های دسترسی 🚧 (Restrictions on Access Modifiers)
هنگام override کردن یک تابع از کلاس پایه (base class)، سطح دسترسی بر روی تابع override شده 
باید یکسان باشد؛ برای مثال:

```Cs
class BaseClass { protected virtual void Foo() {} }
class Subclass1 : BaseClass { protected override void Foo() {} } // OK
class Subclass2 : BaseClass { public override void Foo() {} } // Error
```
(یک استثنا زمانی است که یک متد protected internal را در یک اسمبلی دیگر override می‌کنید، که 
در این حالت override باید فقط protected باشد.)

کامپایلر از هرگونه استفاده ناسازگار از اصلاح‌کننده‌های دسترسی جلوگیری می‌کند. برای مثال، یک زیرکلاس خود می‌تواند کمتر از یک کلاس پایه قابل دسترسی باشد، اما نه بیشتر:

```Cs
internal class A {}
public class B : A {} // Error
```





